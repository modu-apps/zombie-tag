{
  "version": 3,
  "sources": ["cdn-global:modu-engine", "../src/game.ts", "../src/constants.ts", "../src/entities.ts", "../src/systems.ts", "../src/render.ts"],
  "sourcesContent": ["module.exports = window.Modu;", "/**\n * Brains Game - Zombie Tag Multiplayer\n * Build: 2026-01-08\n *\n * Properly structured TypeScript implementation following engine best practices.\n * Build auto-transforms: dSqrt() -> dSqrt(), dRandom() -> dRandom()\n */\n\nimport { createGame,\n    Game,\n    Entity,\n    Transform2D,\n    Body2D,\n    Player,\n    Sprite,\n    Camera2D,\n    Simple2DRenderer,\n    Physics2DSystem,\n    InputPlugin,\n    enableDebugUI, dSqrt, dRandom } from 'modu-engine';\n\nimport {\n    TEAM_HUMAN,\n    PHASE_WAITING,\n    PHASE_ENDED,\n} from './constants';\n\nimport type { GameConfig, SpriteCache } from './types';\nimport { defineEntities, TeamComponent, GamePhaseComponent, TileData, FurnitureData } from './entities';\nimport { setupSystems, setupCollisions, getGameStateEntity, getSortedPlayers } from './systems';\nimport { createRenderer, createUIUpdater, loadSprites } from './render';\n\n// ============================================\n// Game State\n// ============================================\n\nlet game: Game;\nlet renderer: Simple2DRenderer;\nlet physics: Physics2DSystem;\nlet input: InputPlugin;\nlet cameraEntity: Entity;\n\nlet canvas: HTMLCanvasElement;\nlet config: GameConfig;\nlet tileSize: number;\nlet mapWidth: number;\nlet mapHeight: number;\nlet playerRadius: number;\n\n// Canvas dimensions for aiming system\nlet WIDTH: number;\nlet HEIGHT: number;\n\n// Manual key tracking (InputPlugin's deduplication rounds small values to 0)\n// The engine's inputToString rounds by 10, so -1/0/1 becomes 0\nconst keysDown = new Set<string>();\n\n/**\n * Get scaled movement vector from tracked keys\n * Returns values like 100/-100 instead of 1/-1 to survive InputPlugin's rounding\n */\nfunction getMovementVector(): { x: number; y: number } {\n    let x = 0, y = 0;\n    if (keysDown.has('a') || keysDown.has('arrowleft')) x -= 100;\n    if (keysDown.has('d') || keysDown.has('arrowright')) x += 100;\n    if (keysDown.has('w') || keysDown.has('arrowup')) y -= 100;\n    if (keysDown.has('s') || keysDown.has('arrowdown')) y += 100;\n    return { x, y };\n}\n\nconst spriteCache: SpriteCache = {\n    sprites: new Map(),\n    tilesheetImg: null,\n    tileCols: 1\n};\n\n// ============================================\n// Helper Functions\n// ============================================\n\nfunction getLocalClientId(): number | null {\n    const clientId = game.localClientId;\n    if (!clientId || typeof clientId !== 'string') return null;\n    return game.internClientId(clientId);\n}\n\n/**\n * Ensure camera entity exists (survives snapshot loads)\n */\nfunction ensureCameraEntity(): Entity {\n    if (!cameraEntity || cameraEntity.destroyed || !cameraEntity.has(Camera2D)) {\n        cameraEntity = game.spawn('camera');\n        const cam = cameraEntity.get(Camera2D);\n        cam.x = mapWidth / 2;\n        cam.y = mapHeight / 2;\n        cam.smoothing = 0.15;\n        renderer.camera = cameraEntity;\n    }\n    return cameraEntity;\n}\n\n// ============================================\n// Room Creation - Map Setup\n// ============================================\n\nfunction createMap(): void {\n    // Create game-state entity to hold authoritative game phase\n    const stateEntity = game.spawn('game-state', {\n        phase: PHASE_WAITING,\n        gameTick: 0,\n        phaseStartTick: 0,\n        sickInfectionTick: 0,\n        outbreakTick: 0\n    });\n\n    // Create floor tiles\n    const floorLayer = config.map.layers.find(l => l.name === 'floor' || l.name.includes('floor'));\n    if (floorLayer) {\n        for (let i = 0; i < floorLayer.data.length; i++) {\n            if (floorLayer.data[i] !== 0) {\n                const tx = (i % config.map.width) * tileSize + tileSize / 2;\n                const ty = Math.floor(i / config.map.width) * tileSize + tileSize / 2;\n                game.spawn('_floor', { x: tx, y: ty, tileId: floorLayer.data[i] });\n            }\n        }\n    }\n\n    // Create walls\n    const wallLayer = config.map.layers.find(l => l.name === 'walls' || l.name === 'collision');\n    if (wallLayer) {\n        for (let i = 0; i < wallLayer.data.length; i++) {\n            if (wallLayer.data[i] !== 0) {\n                const tx = (i % config.map.width) * tileSize + tileSize / 2;\n                const ty = Math.floor(i / config.map.width) * tileSize + tileSize / 2;\n                game.spawn('wall', { x: tx, y: ty, tileId: wallLayer.data[i] });\n            }\n        }\n    }\n\n    // Create furniture\n    config.initialEntities.forEach((e, configIndex) => {\n        const type = config.entityTypes.furniture[e.type];\n        if (!type) return;\n\n        const w = (e.width || type.width) * tileSize;\n        const h = (e.height || type.height) * tileSize;\n        const x = e.x * tileSize;\n        const y = e.y * tileSize;\n        const spriteUrlId = game.internString('spriteUrl', type.sprite);\n        const angleDegrees = e.angle || 0;\n        const angleRadians = (angleDegrees * Math.PI) / 180;\n\n        // Calculate mass based on furniture size\n        const area = (w * h) / (tileSize * tileSize);\n        let mass = 2 + area * 0.5;\n\n        // Make certain furniture types heavier\n        if (['sofa', 'couch', 'bigTable', 'bed', 'tank'].includes(e.type)) {\n            mass *= 2;\n        } else if (['tv', 'smallTable'].includes(e.type)) {\n            mass *= 1.5;\n        }\n\n        const furniture = game.spawn('furniture', {\n            x, y,\n            angle: angleRadians,\n            width: w,\n            height: h,\n            mass: mass,\n            angularVelocity: 0\n        });\n\n        // Ensure Body2D dimensions are set\n        const body = furniture.get(Body2D);\n        if (body) {\n            body.width = w;\n            body.height = h;\n            body.mass = mass;\n            body.angularVelocity = 0;\n        }\n\n        // Store config index for round reset - MUST set manually after spawn\n        const furnitureData = furniture.get(FurnitureData);\n        if (furnitureData) {\n            furnitureData.spriteUrlId = spriteUrlId;\n            furnitureData.w = w;\n            furnitureData.h = h;\n            furnitureData.configIndex = configIndex;\n        }\n    });\n}\n\n// ============================================\n// Player Spawn/Despawn\n// ============================================\n\nfunction spawnPlayer(clientId: string): void {\n    const spawn = config.regions.spawn;\n    const x = (spawn.x + dRandom() * spawn.width) * tileSize;\n    const y = (spawn.y + dRandom() * spawn.height) * tileSize;\n\n    game.spawn('player', {\n        x, y,\n        clientId,\n        team: TEAM_HUMAN,\n        score: 0,\n        aimAngle: 0\n    });\n}\n\nfunction despawnPlayer(clientId: string): void {\n    const numericId = game.internClientId(clientId);\n    const entity = game.getEntityByClientId(numericId);\n    entity?.destroy();\n}\n\n// ============================================\n// Main Entry Point\n// ============================================\n\nexport async function initGame(): Promise<void> {\n    // Load configuration\n    const res = await fetch('brains.json');\n    const data = await res.json();\n    config = data.game as GameConfig;\n\n    tileSize = config.metadata.tileSize;\n    mapWidth = config.map.width * tileSize;\n    mapHeight = config.map.height * tileSize;\n    playerRadius = config.entityTypes.player.human.width * tileSize;\n\n    // Setup canvas\n    canvas = document.getElementById('game') as HTMLCanvasElement;\n    canvas.width = Math.min(mapWidth, window.innerWidth - 40);\n    canvas.height = Math.min(mapHeight, window.innerHeight - 40);\n    WIDTH = canvas.width;\n    HEIGHT = canvas.height;\n\n    // Handle window resize\n    window.addEventListener('resize', () => {\n        canvas.width = Math.min(mapWidth, window.innerWidth - 40);\n        canvas.height = Math.min(mapHeight, window.innerHeight - 40);\n        WIDTH = canvas.width;\n        HEIGHT = canvas.height;\n    });\n\n    // Manual keyboard tracking - bypasses InputPlugin's deduplication issue\n    // The engine rounds input values by 10, so small values like -1/0/1 become 0\n    window.addEventListener('keydown', (e) => {\n        keysDown.add(e.key.toLowerCase());\n    });\n    window.addEventListener('keyup', (e) => {\n        keysDown.delete(e.key.toLowerCase());\n    });\n    // Clear keys when window loses focus to prevent stuck keys\n    window.addEventListener('blur', () => {\n        keysDown.clear();\n    });\n\n    // Create game instance\n    game = createGame();\n    physics = game.addPlugin(Physics2DSystem, { gravity: { x: 0, y: 0 } });\n    renderer = game.addPlugin(Simple2DRenderer, canvas);\n    input = game.addPlugin(InputPlugin, canvas);\n\n    // Expose for debugging\n    (window as any).game = game;\n\n    // Define entities\n    defineEntities(game, tileSize, playerRadius);\n\n    // Load sprites\n    await loadSprites(config, spriteCache);\n\n    // Hide loading, show UI\n    document.getElementById('loading')!.style.display = 'none';\n    document.getElementById('ui')!.style.display = 'block';\n\n    // Setup input actions\n    // Movement input - uses manual key tracking with scaled values\n    // The callback returns values like 100/-100 which survive InputPlugin's rounding\n    input.action('move', {\n        type: 'vector',\n        bindings: [getMovementVector]\n    });\n\n    // Aim input - raw mouse position on canvas\n    // Direction is calculated in the aiming system relative to screen center\n    input.action('aim', {\n        type: 'vector',\n        bindings: ['mouse']\n    });\n\n    // Create camera entity\n    cameraEntity = game.spawn('camera');\n    const cam = cameraEntity.get(Camera2D);\n    cam.x = mapWidth / 2;\n    cam.y = mapHeight / 2;\n    cam.smoothing = 0.15;\n    renderer.camera = cameraEntity;\n\n    // Create UI updater\n    const phaseEl = document.getElementById('phase')!;\n    const scoreEl = document.getElementById('score')!;\n    const updateUI = createUIUpdater(game, phaseEl, scoreEl);\n\n    // Setup systems\n    setupSystems(game, config, tileSize, WIDTH, HEIGHT, updateUI);\n    setupCollisions(game, physics, tileSize);\n\n    // Create renderer\n    const renderFn = createRenderer(\n        game, renderer, ensureCameraEntity, canvas, config, tileSize, playerRadius,\n        spriteCache, getLocalClientId\n    );\n    renderer.render = renderFn;\n\n    // Connect to server with proper callbacks including onSnapshot\n    game.connect('brains', {\n        onRoomCreate() {\n            createMap();\n        },\n\n        onConnect(clientId: string) {\n            spawnPlayer(clientId);\n        },\n\n        onDisconnect(clientId: string) {\n            despawnPlayer(clientId);\n        },\n\n        /**\n         * CRITICAL: onSnapshot handler for late joiners\n         *\n         * When a client joins late, they receive a snapshot of the current game state.\n         * This callback allows us to properly synchronize client state with the server.\n         *\n         * Without this, late joiners would have divergent state and desync issues.\n         */\n        onSnapshot(entities: Entity[]) {\n            // Find local player and center camera on them\n            const localId = getLocalClientId();\n            if (localId !== null) {\n                for (const entity of entities) {\n                    if (entity.type === 'player' && !entity.destroyed) {\n                        const playerComp = entity.get(Player);\n                        if (playerComp.clientId === localId) {\n                            const transform = entity.get(Transform2D);\n                            const camEntity = ensureCameraEntity();\n                            const cam = camEntity.get(Camera2D);\n                            cam.x = transform.x;\n                            cam.y = transform.y;\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n    });\n\n    // Enable debug UI\n    enableDebugUI(game);\n\n    // Handle round restart after end\n    // This is done client-side with a check to ensure determinism\n    game.addSystem(() => {\n        const stateEntity = getGameStateEntity(game);\n        if (!stateEntity) return;\n\n        const state = stateEntity.get(GamePhaseComponent);\n\n        // Check if round ended and enough time has passed (5 seconds = 100 ticks)\n        if (state.phase === PHASE_ENDED) {\n            const ticksSinceEnd = state.gameTick - state.phaseStartTick;\n            if (ticksSinceEnd >= 100) {  // 5 seconds at 20 tick rate\n                const players = getSortedPlayers(game);\n                if (players.length >= 2) {\n                    // Reset to preoutbreak\n                    state.phase = 1; // PHASE_PREOUTBREAK\n                    state.phaseStartTick = state.gameTick;\n                    state.sickInfectionTick = 0;\n                    state.outbreakTick = 0;\n\n                    // Reset all players to human and respawn at spawn area\n                    const spawn = config.regions.spawn;\n                    const spawnCenterX = (spawn.x + spawn.width / 2) * tileSize;\n                    const spawnCenterY = (spawn.y + spawn.height / 2) * tileSize;\n\n                    for (let i = 0; i < players.length; i++) {\n                        const player = players[i];\n                        const teamComp = player.get(TeamComponent);\n                        teamComp.team = TEAM_HUMAN;\n                        teamComp.score = 0;\n\n                        // Reset position to spawn area (deterministic based on player index)\n                        const transform = player.get(Transform2D);\n                        const body = player.get(Body2D);\n                        // Spread players in a grid pattern around spawn center\n                        const col = i % 4;\n                        const row = Math.floor(i / 4);\n                        const offsetX = (col - 1.5) * playerRadius * 3;\n                        const offsetY = (row - 0.5) * playerRadius * 3;\n                        transform.x = spawnCenterX + offsetX;\n                        transform.y = spawnCenterY + offsetY;\n                        // Stop movement\n                        if (body) {\n                            body.vx = 0;\n                            body.vy = 0;\n                        }\n                    }\n\n                    // Reset all furniture by destroying and recreating from config\n                    // This is the only reliable way since physics engine has internal state\n                    const furniture = [...game.query('furniture')];\n                    for (const f of furniture) {\n                        f.destroy();\n                    }\n\n                    // Recreate all furniture from config\n                    config.initialEntities.forEach((e, configIndex) => {\n                        const type = config.entityTypes.furniture[e.type];\n                        if (!type) return;\n\n                        const w = (e.width || type.width) * tileSize;\n                        const h = (e.height || type.height) * tileSize;\n                        const x = e.x * tileSize;\n                        const y = e.y * tileSize;\n                        const spriteUrlId = game.internString('spriteUrl', type.sprite);\n                        const angleDegrees = e.angle || 0;\n                        const angleRadians = (angleDegrees * Math.PI) / 180;\n\n                        const area = (w * h) / (tileSize * tileSize);\n                        let mass = 2 + area * 0.5;\n                        if (['sofa', 'couch', 'bigTable', 'bed', 'tank'].includes(e.type)) {\n                            mass *= 2;\n                        } else if (['tv', 'smallTable'].includes(e.type)) {\n                            mass *= 1.5;\n                        }\n\n                        const newFurniture = game.spawn('furniture', {\n                            x, y,\n                            angle: angleRadians,\n                            width: w,\n                            height: h,\n                            mass: mass,\n                            angularVelocity: 0\n                        });\n\n                        const body = newFurniture.get(Body2D);\n                        if (body) {\n                            body.width = w;\n                            body.height = h;\n                            body.mass = mass;\n                            body.angularVelocity = 0;\n                        }\n\n                        const furnitureData = newFurniture.get(FurnitureData);\n                        if (furnitureData) {\n                            furnitureData.spriteUrlId = spriteUrlId;\n                            furnitureData.w = w;\n                            furnitureData.h = h;\n                            furnitureData.configIndex = configIndex;\n                        }\n                    });\n\n                } else {\n                    // Not enough players, go back to waiting\n                    state.phase = PHASE_WAITING;\n                }\n            }\n        }\n    }, { phase: 'update' });\n}\n\n// Auto-init when DOM is ready\nif (document.readyState === 'loading') {\n    document.addEventListener('DOMContentLoaded', initGame);\n} else {\n    initGame();\n}\n", "/**\n * Brains Game Constants\n *\n * All game constants extracted for easy tuning and reuse across modules.\n */\n\n// Tile and map dimensions (will be loaded from config)\nexport const DEFAULT_TILE_SIZE = 64;\n\n// Team types - MUST match across all files\nexport const TEAM_HUMAN = 0;\nexport const TEAM_ZOMBIE = 1;\nexport const TEAM_SICK = 2;\n\n// Game phase types\nexport const PHASE_WAITING = 0;\nexport const PHASE_PREOUTBREAK = 1;\nexport const PHASE_POSTOUTBREAK = 2;\nexport const PHASE_ENDED = 3;\n\n// Timing (in ticks at 20 tick rate)\nexport const TICK_RATE = 20;\nexport const TIME_PREOUTBREAK = 60 * TICK_RATE;  // 60 seconds\nexport const TIME_SICK = 15 * TICK_RATE;         // 15 seconds before outbreak\nexport const OUTBREAK_RATIO = 0.3;               // 30% of players become sick\n\n// Player speeds (from config, these are defaults)\nexport const DEFAULT_HUMAN_SPEED = 6.5;\nexport const DEFAULT_ZOMBIE_SPEED = 6;\nexport const DEFAULT_SICK_SPEED = 2;\n\n// Physics\nexport const INFECTION_DISTANCE_TILES = 1.2;  // In tile units\n\n// Player colors (for fallback)\nexport const HUMAN_COLOR = '#4ecdc4';\nexport const ZOMBIE_COLOR = '#e94560';\nexport const SICK_COLOR = '#ff9f43';\n", "/**\n * Brains Game Entity Definitions\n *\n * Components and entity type registrations.\n * Uses proper GamePhase component instead of storing state in Sprite.\n */\n\nimport {\n    Game,\n    Transform2D,\n    Body2D,\n    Player,\n    Sprite,\n    Camera2D,\n    BODY_KINEMATIC,\n    BODY_STATIC,\n    BODY_DYNAMIC,\n    SHAPE_CIRCLE,\n    SHAPE_RECT,\n    defineComponent,\n} from 'modu-engine';\n\nimport {\n    TEAM_HUMAN,\n    PHASE_WAITING,\n} from './constants';\n\n// ============================================\n// Custom Components\n// ============================================\n\n/**\n * Team component - stores player team and score\n */\nexport const TeamComponent = defineComponent('Team', {\n    team: TEAM_HUMAN,       // 0=human, 1=zombie, 2=sick\n    score: 0,\n    aimAngle: { type: 'f32', default: 0 }\n});\n\n/**\n * GamePhase component - stores authoritative game state\n * Attached to a dedicated game-state entity for proper synchronization.\n * This replaces the hacky pattern of storing game state in Sprite component.\n */\nexport const GamePhaseComponent = defineComponent('GamePhase', {\n    phase: PHASE_WAITING,      // 0=waiting, 1=preoutbreak, 2=postoutbreak, 3=ended\n    gameTick: 0,\n    phaseStartTick: 0,\n    sickInfectionTick: 0,\n    outbreakTick: 0\n});\n\n/**\n * TileData component - stores tile ID for floor/wall rendering\n */\nexport const TileData = defineComponent('TileData', {\n    tileId: 0\n});\n\n/**\n * FurnitureData component - stores furniture sprite, dimensions, and config index\n * Config index is used to look up initial position from config.initialEntities on round restart\n */\nexport const FurnitureData = defineComponent('FurnitureData', {\n    spriteUrlId: 0,  // Interned string ID\n    w: { type: 'f32', default: 64 },\n    h: { type: 'f32', default: 64 },\n    configIndex: 0   // Index in config.initialEntities for position reset\n});\n\n// ============================================\n// Entity Definitions\n// ============================================\n\nexport function defineEntities(game: Game, tileSize: number, playerRadius: number): void {\n    // Game state entity - holds authoritative game phase data\n    // This entity syncs game state to all clients properly\n    game.defineEntity('game-state')\n        .with(GamePhaseComponent)\n        .register();\n\n    // Floor tiles - visual only, sensor body\n    game.defineEntity('_floor')\n        .with(Transform2D)\n        .with(Sprite, { shape: SHAPE_RECT, width: tileSize, height: tileSize, layer: 0, visible: false })\n        .with(Body2D, { shapeType: SHAPE_RECT, width: tileSize, height: tileSize, bodyType: BODY_STATIC, isSensor: true })\n        .with(TileData)\n        .register();\n\n    // Walls - solid collision\n    game.defineEntity('wall')\n        .with(Transform2D)\n        .with(Sprite, { shape: SHAPE_RECT, width: tileSize, height: tileSize, layer: 1, visible: false })\n        .with(Body2D, { shapeType: SHAPE_RECT, width: tileSize, height: tileSize, bodyType: BODY_STATIC })\n        .with(TileData)\n        .register();\n\n    // Furniture - dynamic physics objects (pushable)\n    game.defineEntity('furniture')\n        .with(Transform2D)\n        .with(Sprite, { shape: SHAPE_RECT, layer: 2, visible: false })\n        .with(Body2D, {\n            shapeType: SHAPE_RECT,\n            bodyType: BODY_DYNAMIC,\n            mass: 5,\n            restitution: 0.2,\n            friction: 0.5,\n            damping: 0.15,\n            width: tileSize,\n            height: tileSize\n        })\n        .with(FurnitureData)\n        .register();\n\n    // Player - kinematic body with team data\n    game.defineEntity('player')\n        .with(Transform2D)\n        .with(Sprite, { shape: SHAPE_CIRCLE, radius: playerRadius, layer: 3 })\n        .with(Body2D, { shapeType: SHAPE_CIRCLE, radius: playerRadius, bodyType: BODY_KINEMATIC })\n        .with(Player)\n        .with(TeamComponent)\n        .register();\n\n    // Camera entity - client-only, excluded from snapshots\n    game.defineEntity('camera')\n        .with(Camera2D, { smoothing: 0.15 })\n        .syncNone()\n        .register();\n}\n", "/**\n * Brains Game Systems\n *\n * All game systems with proper deterministic ordering using string ID comparison.\n * Systems are split into focused units for maintainability.\n */\n\nimport { Game,\n    Entity,\n    Transform2D,\n    Body2D,\n    Player,\n    Sprite,\n    Physics2DSystem,\n    toFixed,\n    toFloat,\n    fpMul, dSqrt } from 'modu-engine';\n\nimport {\n    TEAM_HUMAN,\n    TEAM_ZOMBIE,\n    TEAM_SICK,\n    PHASE_WAITING,\n    PHASE_PREOUTBREAK,\n    PHASE_POSTOUTBREAK,\n    PHASE_ENDED,\n    TIME_PREOUTBREAK,\n    TIME_SICK,\n    OUTBREAK_RATIO,\n} from './constants';\n\nimport { TeamComponent, GamePhaseComponent, FurnitureData } from './entities';\nimport type { GameConfig } from './types';\n\n// ============================================\n// Helper Functions - Deterministic Sorting\n// ============================================\n\n/**\n * Get string form of a numeric client ID\n */\nexport function getClientIdStr(game: Game, numericId: number): string {\n    return game.getClientIdString(numericId) || '';\n}\n\n/**\n * Compare strings for deterministic sorting\n * CRITICAL: This ensures identical ordering on all clients\n */\nfunction compareStrings(a: string, b: string): number {\n    if (a < b) return -1;\n    if (a > b) return 1;\n    return 0;\n}\n\n/**\n * Get players sorted deterministically by client ID STRING (not numeric)\n * This is CRITICAL for preventing divergence across clients\n */\nexport function getSortedPlayers(game: Game): Entity[] {\n    const players = [...game.query('player')].filter(p => !p.destroyed);\n\n    // Sort by entity ID first for stable iteration, then by client string\n    players.sort((a, b) => {\n        const aStr = getClientIdStr(game, a.get(Player).clientId);\n        const bStr = getClientIdStr(game, b.get(Player).clientId);\n        return compareStrings(aStr, bStr);\n    });\n\n    return players;\n}\n\n/**\n * Get the game state entity (creates if needed on room creation)\n */\nexport function getGameStateEntity(game: Game): Entity | null {\n    const stateEntities = [...game.query('game-state')];\n    return stateEntities.length > 0 ? stateEntities[0] : null;\n}\n\n// ============================================\n// Movement System\n// ============================================\n\nexport function createMovementSystem(\n    game: Game,\n    config: GameConfig\n): () => void {\n    const HUMAN_SPEED = config.entityTypes.player.human.speed;\n    const ZOMBIE_SPEED = config.entityTypes.player.zombie.speed;\n    const SICK_SPEED = config.entityTypes.player.sick.speed;\n\n    // Fixed-point constant for diagonal normalization\n    const INV_SQRT2 = 46341; // 0.7071 * 65536\n\n    return () => {\n        const sortedPlayers = getSortedPlayers(game);\n\n        for (const player of sortedPlayers) {\n            const playerComp = player.get(Player);\n            const teamComp = player.get(TeamComponent);\n            const inputData = game.world.getInput(playerComp.clientId);\n\n            if (!inputData) continue;\n\n            // Movement with WASD\n            if (inputData.move && (inputData.move.x !== 0 || inputData.move.y !== 0)) {\n                const mx = inputData.move.x > 0 ? 1 : inputData.move.x < 0 ? -1 : 0;\n                const my = inputData.move.y > 0 ? 1 : inputData.move.y < 0 ? -1 : 0;\n\n                // Score-based speed multiplier\n                const scoreMultiplier = 1 + teamComp.score / 30000;\n                let speed: number;\n\n                if (teamComp.team === TEAM_HUMAN) {\n                    speed = HUMAN_SPEED * scoreMultiplier;\n                } else if (teamComp.team === TEAM_ZOMBIE) {\n                    speed = ZOMBIE_SPEED * scoreMultiplier;\n                } else {\n                    speed = SICK_SPEED * scoreMultiplier;\n                }\n\n                let vx = mx * speed * 60;\n                let vy = my * speed * 60;\n\n                // Normalize diagonal movement using fixed-point math\n                if (mx !== 0 && my !== 0) {\n                    vx = toFloat(fpMul(toFixed(vx), INV_SQRT2));\n                    vy = toFloat(fpMul(toFixed(vy), INV_SQRT2));\n                }\n\n                player.setVelocity(vx, vy);\n            } else {\n                player.setVelocity(0, 0);\n            }\n        }\n    };\n}\n\n// ============================================\n// Aiming System\n// ============================================\n\nexport function createAimingSystem(game: Game, canvasWidth: number, canvasHeight: number): () => void {\n    const centerX = canvasWidth / 2;\n    const centerY = canvasHeight / 2;\n\n    return () => {\n        const sortedPlayers = getSortedPlayers(game);\n\n        for (const player of sortedPlayers) {\n            const playerComp = player.get(Player);\n            const teamComp = player.get(TeamComponent);\n            const inputData = game.world.getInput(playerComp.clientId);\n\n            if (!inputData?.aim) continue;\n\n            // Input provides raw mouse position on canvas\n            const aim = inputData.aim;\n            let mouseX = centerX;\n            let mouseY = centerY;\n\n            if (Array.isArray(aim)) {\n                mouseX = aim[0] || centerX;\n                mouseY = aim[1] || centerY;\n            } else if (typeof aim === 'object') {\n                mouseX = aim.x || centerX;\n                mouseY = aim.y || centerY;\n            }\n\n            // Calculate direction from screen center to mouse position\n            const dx = mouseX - centerX;\n            const dy = mouseY - centerY;\n\n            // Convert to angle (add PI/2 so \"up\" in screen space points forward)\n            teamComp.aimAngle = Math.atan2(dy, dx) + Math.PI / 2;\n        }\n    };\n}\n\n// ============================================\n// Game Phase Management System\n// ============================================\n\nexport function createGamePhaseSystem(\n    game: Game,\n    updateUI: () => void\n): () => void {\n    return () => {\n        const stateEntity = getGameStateEntity(game);\n        if (!stateEntity) return;\n\n        const state = stateEntity.get(GamePhaseComponent);\n        state.gameTick++;\n\n        const players = getSortedPlayers(game);\n\n        // Auto-start round when 2+ players join\n        if (state.phase === PHASE_WAITING && players.length >= 2) {\n            startRound(game, stateEntity);\n        }\n\n        // Phase transitions\n        const ticksInPhase = state.gameTick - state.phaseStartTick;\n\n        if (state.phase === PHASE_PREOUTBREAK) {\n            // Make players sick 45 seconds in (15 seconds before outbreak)\n            if (state.sickInfectionTick === 0 && ticksInPhase >= (TIME_PREOUTBREAK - TIME_SICK)) {\n                makeSomePlayersSick(game, stateEntity);\n            }\n\n            // Start outbreak at 60 seconds\n            if (ticksInPhase >= TIME_PREOUTBREAK) {\n                startOutbreak(game, stateEntity);\n            }\n        }\n\n        if (state.phase === PHASE_POSTOUTBREAK) {\n            // Check win conditions\n            const humans = players.filter(p => p.get(TeamComponent).team === TEAM_HUMAN).length;\n            const zombies = players.filter(p => p.get(TeamComponent).team === TEAM_ZOMBIE).length;\n\n            if (humans === 0 && zombies > 0) {\n                endRound(game, stateEntity, 'zombies');\n            } else if (zombies === 0 && humans > 0) {\n                endRound(game, stateEntity, 'humans');\n            }\n        }\n\n        updateUI();\n    };\n}\n\n// ============================================\n// Infection System\n// ============================================\n\nexport function createInfectionSystem(\n    game: Game,\n    infectionDist: number\n): () => void {\n    return () => {\n        const stateEntity = getGameStateEntity(game);\n        if (!stateEntity) return;\n\n        const state = stateEntity.get(GamePhaseComponent);\n        if (state.phase !== PHASE_POSTOUTBREAK) return;\n\n        const players = getSortedPlayers(game);\n\n        // Process zombies in deterministic order\n        for (const zombie of players) {\n            const zombieTeam = zombie.get(TeamComponent);\n            if (zombieTeam.team !== TEAM_ZOMBIE) continue;\n\n            const zombieTransform = zombie.get(Transform2D);\n\n            // Check against all humans in deterministic order\n            for (const human of players) {\n                const humanTeam = human.get(TeamComponent);\n                if (humanTeam.team !== TEAM_HUMAN) continue;\n\n                const humanTransform = human.get(Transform2D);\n                const dx = zombieTransform.x - humanTransform.x;\n                const dy = zombieTransform.y - humanTransform.y;\n                const dist = dSqrt(dx * dx + dy * dy);\n\n                if (dist < infectionDist) {\n                    humanTeam.team = TEAM_ZOMBIE;\n                    zombieTeam.score++;\n                }\n            }\n        }\n    };\n}\n\n// ============================================\n// Helper Functions for Game Phase\n// ============================================\n\nfunction startRound(game: Game, stateEntity: Entity): void {\n    const state = stateEntity.get(GamePhaseComponent);\n\n    state.phase = PHASE_PREOUTBREAK;\n    state.phaseStartTick = state.gameTick;\n    state.sickInfectionTick = 0;\n    state.outbreakTick = 0;\n\n    // Reset ALL players to human (in deterministic order)\n    const players = getSortedPlayers(game);\n    for (const player of players) {\n        const teamComp = player.get(TeamComponent);\n        teamComp.team = TEAM_HUMAN;\n        teamComp.score = 0;\n    }\n}\n\nfunction makeSomePlayersSick(game: Game, stateEntity: Entity): void {\n    const state = stateEntity.get(GamePhaseComponent);\n    const players = getSortedPlayers(game);\n\n    // Filter humans only (already sorted deterministically)\n    const humans = players.filter(p => p.get(TeamComponent).team === TEAM_HUMAN);\n    const numToInfect = Math.max(1, Math.floor(humans.length * OUTBREAK_RATIO));\n\n    // Deterministic shuffle using tick number\n    const shuffled = [...humans];\n    for (let i = shuffled.length - 1; i > 0; i--) {\n        const j = (state.gameTick + i) % (i + 1);\n        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];\n    }\n\n    for (let i = 0; i < numToInfect && i < shuffled.length; i++) {\n        shuffled[i].get(TeamComponent).team = TEAM_SICK;\n    }\n\n    state.sickInfectionTick = state.gameTick;\n}\n\nfunction startOutbreak(game: Game, stateEntity: Entity): void {\n    const state = stateEntity.get(GamePhaseComponent);\n\n    state.phase = PHASE_POSTOUTBREAK;\n    state.outbreakTick = state.gameTick;\n\n    // Convert all sick players to zombies (in deterministic order)\n    const players = getSortedPlayers(game);\n    for (const player of players) {\n        const teamComp = player.get(TeamComponent);\n        if (teamComp.team === TEAM_SICK) {\n            teamComp.team = TEAM_ZOMBIE;\n        }\n    }\n}\n\nfunction endRound(game: Game, stateEntity: Entity, winner: string): void {\n    const state = stateEntity.get(GamePhaseComponent);\n    state.phase = PHASE_ENDED;\n    state.phaseStartTick = state.gameTick;  // CRITICAL: Set this so the 5-second timer works\n}\n\n// ============================================\n// Collision Handlers\n// ============================================\n\nexport function setupCollisions(\n    game: Game,\n    physics: Physics2DSystem,\n    tileSize: number\n): void {\n    // Player-furniture collision: Apply push force for responsiveness\n    physics.onCollision('player', 'furniture', (player, furniture) => {\n        const playerTransform = player.get(Transform2D);\n        const furnitureTransform = furniture.get(Transform2D);\n        const furnitureBody = furniture.get(Body2D);\n        const playerBody = player.get(Body2D);\n        const furnitureData = furniture.get(FurnitureData);\n\n        if (!playerTransform || !furnitureTransform || !furnitureBody || !playerBody) return;\n\n        // Skip if player is not moving\n        const playerSpeed = dSqrt(playerBody.vx * playerBody.vx + playerBody.vy * playerBody.vy);\n        if (playerSpeed < 10) return;\n\n        // Get furniture dimensions\n        const furnitureWidth = furnitureData ? furnitureData.w : tileSize;\n        const furnitureHeight = furnitureData ? furnitureData.h : tileSize;\n\n        // Calculate collision point on furniture's edge\n        const relX = playerTransform.x - furnitureTransform.x;\n        const relY = playerTransform.y - furnitureTransform.y;\n\n        // Clamp to furniture boundaries\n        const halfWidth = furnitureWidth / 2;\n        const halfHeight = furnitureHeight / 2;\n        const collisionX = Math.max(-halfWidth, Math.min(halfWidth, relX));\n        const collisionY = Math.max(-halfHeight, Math.min(halfHeight, relY));\n\n        // Calculate push direction\n        const dx = furnitureTransform.x - playerTransform.x;\n        const dy = furnitureTransform.y - playerTransform.y;\n        const dist = dSqrt(dx * dx + dy * dy);\n\n        if (dist > 0.01) {\n            const pushStrength = Math.min(playerSpeed * 0.4, 120);\n            const pushX = (dx / dist) * pushStrength;\n            const pushY = (dy / dist) * pushStrength;\n\n            // Apply linear impulse\n            furnitureBody.impulseX += pushX;\n            furnitureBody.impulseY += pushY;\n\n            // Calculate and apply torque\n            const torque = (collisionX * pushY - collisionY * pushX) * 0.00001;\n            const massEffect = 3 / (furnitureBody.mass || 5);\n            const adjustedTorque = torque * massEffect;\n\n            const maxAngularVelocity = 0.5;\n            const currentAngVel = furnitureBody.angularVelocity || 0;\n            const newAngularVelocity = currentAngVel + adjustedTorque;\n            furnitureBody.angularVelocity = Math.max(-maxAngularVelocity,\n                Math.min(maxAngularVelocity, newAngularVelocity));\n        }\n    });\n}\n\n// ============================================\n// Setup All Systems\n// ============================================\n\nexport function setupSystems(\n    game: Game,\n    config: GameConfig,\n    tileSize: number,\n    canvasWidth: number,\n    canvasHeight: number,\n    updateUI: () => void\n): void {\n    const infectionDist = 1.2 * tileSize;\n\n    // Add systems in proper order\n    game.addSystem(createMovementSystem(game, config), { phase: 'update' });\n    game.addSystem(createAimingSystem(game, canvasWidth, canvasHeight), { phase: 'update' });\n    game.addSystem(createGamePhaseSystem(game, updateUI), { phase: 'update' });\n    game.addSystem(createInfectionSystem(game, infectionDist), { phase: 'update' });\n}\n", "/**\n * Brains Game Rendering\n *\n * Factory pattern for creating the renderer function.\n * Handles tiles, furniture, players, and UI.\n */\n\nimport {\n    Game,\n    Entity,\n    Simple2DRenderer,\n    Transform2D,\n    Sprite,\n    Player,\n    Camera2D,\n} from 'modu-engine';\n\nimport {\n    TEAM_HUMAN,\n    TEAM_ZOMBIE,\n    TEAM_SICK,\n    PHASE_WAITING,\n    PHASE_PREOUTBREAK,\n    PHASE_POSTOUTBREAK,\n    TIME_PREOUTBREAK,\n    TICK_RATE,\n} from './constants';\n\nimport { TeamComponent, TileData, FurnitureData, GamePhaseComponent } from './entities';\nimport { getGameStateEntity, getSortedPlayers } from './systems';\nimport type { GameConfig, SpriteCache } from './types';\n\n// ============================================\n// Camera Update\n// ============================================\n\nexport function updateCamera(\n    game: Game,\n    cameraEntity: Entity,\n    getLocalClientId: () => number | null,\n    alpha: number\n): void {\n    const localId = getLocalClientId();\n    if (localId === null) return;\n\n    const player = game.world.getEntityByClientId(localId);\n    if (!player || player.destroyed) return;\n\n    const camera = cameraEntity.get(Camera2D);\n\n    // Interpolate player position\n    player.interpolate(alpha);\n    const x = player.render?.interpX ?? player.get(Transform2D).x;\n    const y = player.render?.interpY ?? player.get(Transform2D).y;\n\n    // Smooth camera follow\n    camera.x += (x - camera.x) * camera.smoothing;\n    camera.y += (y - camera.y) * camera.smoothing;\n}\n\n// ============================================\n// Renderer Factory\n// ============================================\n\nexport function createRenderer(\n    game: Game,\n    renderer: Simple2DRenderer,\n    getCameraEntity: () => Entity,\n    canvas: HTMLCanvasElement,\n    config: GameConfig,\n    tileSize: number,\n    playerRadius: number,\n    spriteCache: SpriteCache,\n    getLocalClientId: () => number | null\n): () => void {\n    const ctx = renderer.context;\n    const tileCols = spriteCache.tileCols;\n\n    function renderWithCamera(): void {\n        const cameraEntity = getCameraEntity();\n        const alpha = game.getRenderAlpha();\n        const camera = cameraEntity.get(Camera2D);\n\n        // Update camera to follow local player\n        updateCamera(game, cameraEntity, getLocalClientId, alpha);\n\n        const camX = camera.x;\n        const camY = camera.y;\n\n        // Clear canvas\n        ctx.fillStyle = '#0a0e14';\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n        // Apply camera transform\n        ctx.save();\n        ctx.translate(canvas.width / 2 - camX, canvas.height / 2 - camY);\n        ctx.imageSmoothingEnabled = false;\n\n        // Get all entities and sort by layer\n        const entities = Array.from(game.getAllEntities()).filter(e => !e.destroyed);\n        entities.sort((a, b) => {\n            const aLayer = a.has(Sprite) ? a.get(Sprite).layer : 0;\n            const bLayer = b.has(Sprite) ? b.get(Sprite).layer : 0;\n            return aLayer - bLayer;\n        });\n\n        // Render all entities\n        for (const entity of entities) {\n            if (entity.destroyed) continue;\n\n            // Interpolate position for smooth rendering\n            entity.interpolate(alpha);\n            const pos = { x: entity.render.interpX, y: entity.render.interpY };\n            const type = entity.type;\n\n            // Floor tiles\n            if (type === '_floor' && entity.has(TileData)) {\n                renderTile(ctx, entity, pos, tileSize, spriteCache, tileCols, '#1a2332');\n                continue;\n            }\n\n            // Walls\n            if (type === 'wall' && entity.has(TileData)) {\n                renderTile(ctx, entity, pos, tileSize, spriteCache, tileCols, '#2c3e50');\n                continue;\n            }\n\n            // Furniture\n            if (type === 'furniture' && entity.has(FurnitureData)) {\n                renderFurniture(ctx, game, entity, pos, spriteCache);\n                continue;\n            }\n\n            // Players\n            if (type === 'player' && entity.has(TeamComponent)) {\n                renderPlayer(ctx, game, entity, pos, config, playerRadius, spriteCache);\n            }\n        }\n\n        ctx.restore();\n    }\n\n    return renderWithCamera;\n}\n\n// ============================================\n// Individual Render Functions\n// ============================================\n\nfunction renderTile(\n    ctx: CanvasRenderingContext2D,\n    entity: Entity,\n    pos: { x: number; y: number },\n    tileSize: number,\n    spriteCache: SpriteCache,\n    tileCols: number,\n    fallbackColor: string\n): void {\n    const tileData = entity.get(TileData);\n    const tilesheetImg = spriteCache.tilesheetImg;\n\n    if (tilesheetImg && tileData.tileId) {\n        const tileId = tileData.tileId - 1;\n        const srcX = (tileId % tileCols) * tileSize;\n        const srcY = Math.floor(tileId / tileCols) * tileSize;\n        ctx.drawImage(\n            tilesheetImg,\n            srcX, srcY, tileSize, tileSize,\n            pos.x - tileSize / 2, pos.y - tileSize / 2, tileSize, tileSize\n        );\n    } else {\n        ctx.fillStyle = fallbackColor;\n        ctx.fillRect(pos.x - tileSize / 2, pos.y - tileSize / 2, tileSize, tileSize);\n    }\n}\n\nfunction renderFurniture(\n    ctx: CanvasRenderingContext2D,\n    game: Game,\n    entity: Entity,\n    pos: { x: number; y: number },\n    spriteCache: SpriteCache\n): void {\n    const furnitureData = entity.get(FurnitureData);\n    const transform = entity.get(Transform2D);\n    const spriteUrl = game.getString('spriteUrl', furnitureData.spriteUrlId);\n    const sprite = spriteCache.sprites.get(spriteUrl || '');\n    const w = furnitureData.w;\n    const h = furnitureData.h;\n    const angle = transform ? transform.angle : 0;\n\n    ctx.save();\n    ctx.translate(pos.x, pos.y);\n    if (angle) ctx.rotate(angle);\n\n    if (sprite) {\n        ctx.drawImage(sprite, -w / 2, -h / 2, w, h);\n    } else {\n        ctx.fillStyle = '#7f8c8d';\n        ctx.fillRect(-w / 2, -h / 2, w, h);\n    }\n\n    ctx.restore();\n}\n\nfunction renderPlayer(\n    ctx: CanvasRenderingContext2D,\n    game: Game,\n    entity: Entity,\n    pos: { x: number; y: number },\n    config: GameConfig,\n    playerRadius: number,\n    spriteCache: SpriteCache\n): void {\n    const teamComp = entity.get(TeamComponent);\n    const teamNum = teamComp.team;\n\n    // Get team configuration\n    const teamName = teamNum === TEAM_ZOMBIE ? 'zombie' : teamNum === TEAM_SICK ? 'sick' : 'human';\n    const teamConfig = config.entityTypes.player[teamName];\n    const sprite = spriteCache.sprites.get(teamConfig?.sprite || '');\n    const color = teamConfig?.color || '#fff';\n    const aimAngle = teamComp.aimAngle;\n\n    ctx.save();\n    ctx.translate(pos.x, pos.y);\n    ctx.rotate(aimAngle);\n\n    if (sprite) {\n        ctx.drawImage(sprite, -playerRadius, -playerRadius, playerRadius * 2, playerRadius * 2);\n    } else {\n        // Fallback: colored circle\n        ctx.beginPath();\n        ctx.arc(0, 0, playerRadius, 0, Math.PI * 2);\n        ctx.fillStyle = color;\n        ctx.fill();\n        ctx.strokeStyle = '#fff';\n        ctx.lineWidth = 2;\n        ctx.stroke();\n\n        // Direction indicator\n        ctx.fillStyle = '#fff';\n        ctx.beginPath();\n        ctx.moveTo(playerRadius * 0.5, 0);\n        ctx.lineTo(playerRadius * 0.8, -playerRadius * 0.2);\n        ctx.lineTo(playerRadius * 0.8, playerRadius * 0.2);\n        ctx.fill();\n    }\n\n    ctx.restore();\n}\n\n// ============================================\n// UI Update Function\n// ============================================\n\nexport function createUIUpdater(\n    game: Game,\n    phaseEl: HTMLElement,\n    scoreEl: HTMLElement\n): () => void {\n    return () => {\n        const stateEntity = getGameStateEntity(game);\n        if (!stateEntity) return;\n\n        const state = stateEntity.get(GamePhaseComponent);\n        const players = getSortedPlayers(game);\n\n        const humans = players.filter(p => p.get(TeamComponent).team === TEAM_HUMAN).length;\n        const zombies = players.filter(p => p.get(TeamComponent).team === TEAM_ZOMBIE).length;\n        const sick = players.filter(p => p.get(TeamComponent).team === TEAM_SICK).length;\n\n        const ticksInPhase = state.gameTick - state.phaseStartTick;\n\n        if (state.phase === PHASE_WAITING) {\n            phaseEl.textContent = 'Waiting for players...';\n        } else if (state.phase === PHASE_PREOUTBREAK) {\n            const secondsLeft = Math.max(0, Math.ceil((TIME_PREOUTBREAK - ticksInPhase) / TICK_RATE));\n            phaseEl.innerHTML = `Pre-outbreak: ${secondsLeft}s | <span class=\"team-humans\">Humans: ${humans}</span> | Sick: ${sick}`;\n        } else if (state.phase === PHASE_POSTOUTBREAK) {\n            phaseEl.innerHTML = `<span class=\"team-humans\">Humans: ${humans}</span> | <span class=\"team-zombies\">Zombies: ${zombies}</span>`;\n        } else {\n            phaseEl.textContent = 'Round ended!';\n        }\n    };\n}\n\n// ============================================\n// Sprite Loading\n// ============================================\n\nexport async function loadSprites(\n    config: GameConfig,\n    spriteCache: SpriteCache\n): Promise<void> {\n    const loadSprite = (url: string): Promise<HTMLImageElement | null> => {\n        if (spriteCache.sprites.has(url)) {\n            return Promise.resolve(spriteCache.sprites.get(url)!);\n        }\n\n        return new Promise((resolve) => {\n            const img = new Image();\n            img.crossOrigin = 'anonymous';\n            img.onload = () => {\n                spriteCache.sprites.set(url, img);\n                resolve(img);\n            };\n            img.onerror = () => {\n                console.warn('[Brains] Failed to load:', url);\n                resolve(null);\n            };\n            img.src = url;\n        });\n    };\n\n    // Load tilesheet\n    const tilesheetInfo = config.map.tilesets?.[0];\n    if (tilesheetInfo) {\n        const img = await loadSprite(tilesheetInfo.localImage);\n        spriteCache.tilesheetImg = img;\n        spriteCache.tileCols = tilesheetInfo.columns || 1;\n    }\n\n    // Load player sprites\n    await Promise.all([\n        loadSprite(config.entityTypes.player.human.sprite),\n        loadSprite(config.entityTypes.player.zombie.sprite),\n        loadSprite(config.entityTypes.player.sick.sprite)\n    ]);\n\n    // Load furniture sprites (background)\n    const furniturePromises = Object.values(config.entityTypes.furniture || {}).map(f => {\n        if (f.sprite) return loadSprite(f.sprite);\n        return Promise.resolve(null);\n    });\n    await Promise.all(furniturePromises);\n}\n"],
  "mappings": "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",
  "names": ["import_modu_engine", "game", "tileSize", "playerRadius", "import_modu_engine", "game", "config", "physics", "tileSize", "import_modu_engine", "game", "cameraEntity", "getLocalClientId", "renderer", "canvas", "config", "tileSize", "playerRadius", "spriteCache", "cam"]
}
