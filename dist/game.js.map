{
  "version": 3,
  "sources": ["cdn-global:modu-engine", "../src/game.ts", "../src/constants.ts", "../src/entities.ts", "../src/systems.ts", "../src/render.ts"],
  "sourcesContent": ["module.exports = window.Modu;", "/**\r\n * Brains Game - Zombie Tag Multiplayer\r\n * Build: 2026-01-08\r\n *\r\n * Properly structured TypeScript implementation following engine best practices.\r\n * Build auto-transforms: dSqrt() -> dSqrt(), dRandom() -> dRandom()\r\n */\r\n\r\nimport { createGame,\r\n    Game,\r\n    Entity,\r\n    Transform2D,\r\n    Body2D,\r\n    Player,\r\n    Sprite,\r\n    Camera2D,\r\n    Simple2DRenderer,\r\n    Physics2DSystem,\r\n    InputPlugin,\r\n    enableDebugUI, dSqrt, dRandom } from 'modu-engine';\r\n\r\nimport {\r\n    TEAM_HUMAN,\r\n    PHASE_WAITING,\r\n    PHASE_ENDED,\r\n} from './constants';\r\n\r\nimport type { GameConfig, SpriteCache } from './types';\r\nimport { defineEntities, TeamComponent, GamePhaseComponent, TileData, FurnitureData } from './entities';\r\nimport { setupSystems, setupCollisions, getGameStateEntity, getSortedPlayers, aimAngleCache } from './systems';\r\nimport { createRenderer, createUIUpdater, loadSprites } from './render';\r\n\r\n// ============================================\r\n// Game State\r\n// ============================================\r\n\r\nlet game: Game;\r\nlet renderer: Simple2DRenderer;\r\nlet physics: Physics2DSystem;\r\nlet input: InputPlugin;\r\nlet cameraEntity: Entity;\r\n\r\nlet canvas: HTMLCanvasElement;\r\nlet config: GameConfig;\r\nlet tileSize: number;\r\nlet mapWidth: number;\r\nlet mapHeight: number;\r\nlet playerRadius: number;\r\n\r\n// Canvas dimensions for aiming system\r\nlet WIDTH: number;\r\nlet HEIGHT: number;\r\n\r\n// Mouse tracking for aiming (same pattern as 2d-shooter)\r\nlet mouseX: number;\r\nlet mouseY: number;\r\n\r\nconst spriteCache: SpriteCache = {\r\n    sprites: new Map(),\r\n    tilesheetImg: null,\r\n    tileCols: 1\r\n};\r\n\r\n// ============================================\r\n// Helper Functions\r\n// ============================================\r\n\r\nfunction getLocalClientId(): number | null {\r\n    const clientId = game.localClientId;\r\n    if (!clientId || typeof clientId !== 'string') return null;\r\n    return game.internClientId(clientId);\r\n}\r\n\r\n/**\r\n * Ensure camera entity exists (survives snapshot loads)\r\n */\r\nfunction ensureCameraEntity(): Entity {\r\n    if (!cameraEntity || cameraEntity.destroyed || !cameraEntity.has(Camera2D)) {\r\n        cameraEntity = game.spawn('camera');\r\n        const cam = cameraEntity.get(Camera2D);\r\n        cam.x = mapWidth / 2;\r\n        cam.y = mapHeight / 2;\r\n        cam.smoothing = 0.5;  // Higher = more responsive (0.15 was too laggy)\r\n        renderer.camera = cameraEntity;\r\n    }\r\n    return cameraEntity;\r\n}\r\n\r\n// ============================================\r\n// Room Creation - Map Setup\r\n// ============================================\r\n\r\n/**\r\n * Create static map elements (floors, walls) - called by everyone including late joiners.\r\n * These are .syncNone() so they're not in snapshots - each client creates them locally.\r\n */\r\nfunction createStaticMap(): void {\r\n    // Skip if already created (check for any wall)\r\n    if ([...game.query('wall')].length > 0) return;\r\n\r\n    // Floor tiles are NO LONGER entities - rendered directly from tilemap in render.ts\r\n\r\n    // Create walls (needed for physics collision)\r\n    const wallLayer = config.map.layers.find(l => l.name === 'walls' || l.name === 'collision');\r\n    if (wallLayer) {\r\n        for (let i = 0; i < wallLayer.data.length; i++) {\r\n            if (wallLayer.data[i] !== 0) {\r\n                const tx = (i % config.map.width) * tileSize + tileSize / 2;\r\n                const ty = Math.floor(i / config.map.width) * tileSize + tileSize / 2;\r\n                game.spawn('wall', { x: tx, y: ty, tileId: wallLayer.data[i] });\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction createMap(): void {\r\n    // Create static map (floors, walls)\r\n    createStaticMap();\r\n\r\n    // Create game-state entity to hold authoritative game phase\r\n    const stateEntity = game.spawn('game-state', {\r\n        phase: PHASE_WAITING,\r\n        gameTick: 0,\r\n        phaseStartTick: 0,\r\n        sickInfectionTick: 0,\r\n        outbreakTick: 0\r\n    });\r\n\r\n    // Create furniture\r\n    config.initialEntities.forEach((e, configIndex) => {\r\n        const type = config.entityTypes.furniture[e.type];\r\n        if (!type) return;\r\n\r\n        const w = (e.width || type.width) * tileSize;\r\n        const h = (e.height || type.height) * tileSize;\r\n        const x = e.x * tileSize;\r\n        const y = e.y * tileSize;\r\n        const spriteUrlId = game.internString('spriteUrl', type.sprite);\r\n        const angleDegrees = e.angle || 0;\r\n        const angleRadians = (angleDegrees * Math.PI) / 180;\r\n\r\n        // Calculate mass based on furniture size\r\n        const area = (w * h) / (tileSize * tileSize);\r\n        let mass = 2 + area * 0.5;\r\n\r\n        // Make certain furniture types heavier\r\n        if (['sofa', 'couch', 'bigTable', 'bed', 'tank'].includes(e.type)) {\r\n            mass *= 2;\r\n        } else if (['tv', 'smallTable'].includes(e.type)) {\r\n            mass *= 1.5;\r\n        }\r\n\r\n        const furniture = game.spawn('furniture', {\r\n            x, y,\r\n            angle: angleRadians,\r\n            width: w,\r\n            height: h,\r\n            mass: mass,\r\n            angularVelocity: 0\r\n        });\r\n\r\n        // Ensure Body2D dimensions are set\r\n        const body = furniture.get(Body2D);\r\n        if (body) {\r\n            body.width = w;\r\n            body.height = h;\r\n            body.mass = mass;\r\n            body.angularVelocity = 0;\r\n        }\r\n\r\n        // Store config index for round reset - MUST set manually after spawn\r\n        const furnitureData = furniture.get(FurnitureData);\r\n        if (furnitureData) {\r\n            furnitureData.spriteUrlId = spriteUrlId;\r\n            furnitureData.w = w;\r\n            furnitureData.h = h;\r\n            furnitureData.configIndex = configIndex;\r\n        }\r\n    });\r\n}\r\n\r\n// ============================================\r\n// Player Spawn/Despawn\r\n// ============================================\r\n\r\nfunction spawnPlayer(clientId: string): void {\r\n    // CRITICAL: Check if player entity already exists (from snapshot)\r\n    // This prevents duplicate entity creation that causes desync\r\n    // Must intern first to ensure mapping exists, then use world method with numeric ID\r\n    // (Same pattern as push-box game which doesn't have desync issues)\r\n    const numericId = game.internClientId(clientId);\r\n    const existing = game.world.getEntityByClientId(numericId);\r\n    if (existing) {\r\n        console.log(`[spawn] Player ${clientId.slice(0,8)} already exists (eid=${existing.eid}), skipping spawn`);\r\n        return;\r\n    }\r\n\r\n    const spawn = config.regions.spawn;\r\n    // Fixed spawn position - center of spawn region\r\n    // Using dRandom() causes desync because late joiners have different RNG state during catchup\r\n    const x = (spawn.x + spawn.width / 2) * tileSize;\r\n    const y = (spawn.y + spawn.height / 2) * tileSize;\r\n\r\n    console.log(`[spawn] Creating player ${clientId.slice(0,8)} at (${x.toFixed(0)}, ${y.toFixed(0)})`);\r\n    game.spawn('player', {\r\n        x, y,\r\n        clientId,\r\n        team: TEAM_HUMAN,\r\n        score: 0\r\n    });\r\n}\r\n\r\nfunction despawnPlayer(clientId: string): void {\r\n    const numericId = game.internClientId(clientId);\r\n    const entity = game.getEntityByClientId(numericId);\r\n    if (entity && !entity.destroyed) {\r\n        aimAngleCache.delete(entity.eid);\r\n        entity.destroy();\r\n    }\r\n}\r\n\r\n// ============================================\r\n// Main Entry Point\r\n// ============================================\r\n\r\nexport async function initGame(): Promise<void> {\r\n    // Load configuration\r\n    const res = await fetch('brains.json');\r\n    const data = await res.json();\r\n    config = data.game as GameConfig;\r\n\r\n    tileSize = config.metadata.tileSize;\r\n    mapWidth = config.map.width * tileSize;\r\n    mapHeight = config.map.height * tileSize;\r\n    playerRadius = config.entityTypes.player.human.width * tileSize;\r\n\r\n    // Setup canvas\r\n    canvas = document.getElementById('game') as HTMLCanvasElement;\r\n    canvas.width = Math.min(mapWidth, window.innerWidth - 40);\r\n    canvas.height = Math.min(mapHeight, window.innerHeight - 40);\r\n    WIDTH = canvas.width;\r\n    HEIGHT = canvas.height;\r\n\r\n    // Handle window resize\r\n    window.addEventListener('resize', () => {\r\n        canvas.width = Math.min(mapWidth, window.innerWidth - 40);\r\n        canvas.height = Math.min(mapHeight, window.innerHeight - 40);\r\n        WIDTH = canvas.width;\r\n        HEIGHT = canvas.height;\r\n    });\r\n\r\n    // Mouse tracking for aiming (same pattern as 2d-shooter)\r\n    mouseX = WIDTH / 2;\r\n    mouseY = HEIGHT / 2;\r\n    canvas.addEventListener('mousemove', (e) => {\r\n        const rect = canvas.getBoundingClientRect();\r\n        mouseX = e.clientX - rect.left;\r\n        mouseY = e.clientY - rect.top;\r\n    });\r\n\r\n    // Create game instance\r\n    game = createGame();\r\n    physics = game.addPlugin(Physics2DSystem, { gravity: { x: 0, y: 0 } });\r\n    renderer = game.addPlugin(Simple2DRenderer, canvas);\r\n    input = game.addPlugin(InputPlugin, canvas);\r\n\r\n    // Expose for debugging\r\n    (window as any).game = game;\r\n\r\n    // Define entities\r\n    defineEntities(game, tileSize, playerRadius);\r\n\r\n    // Load sprites\r\n    await loadSprites(config, spriteCache);\r\n\r\n    // Hide loading, show UI\r\n    document.getElementById('loading')!.style.display = 'none';\r\n    document.getElementById('ui')!.style.display = 'block';\r\n\r\n    // Setup input actions\r\n    // Movement input - use callback for full control over key mapping (same pattern as 2d-shooter)\r\n    input.action('move', {\r\n        type: 'vector',\r\n        bindings: [() => {\r\n            let x = 0;\r\n            let y = 0;\r\n            if (input.isKeyDown('w') || input.isKeyDown('arrowup')) y -= 1;\r\n            if (input.isKeyDown('s') || input.isKeyDown('arrowdown')) y += 1;\r\n            if (input.isKeyDown('a') || input.isKeyDown('arrowleft')) x -= 1;\r\n            if (input.isKeyDown('d') || input.isKeyDown('arrowright')) x += 1;\r\n            return { x, y };\r\n        }]\r\n    });\r\n\r\n    // Aim input - raw mouse position on canvas (properly canvas-relative)\r\n    // Direction is calculated in the aiming system relative to screen center\r\n    input.action('aim', {\r\n        type: 'vector',\r\n        bindings: [() => ({ x: mouseX, y: mouseY })]\r\n    });\r\n\r\n    // Create camera entity\r\n    cameraEntity = game.spawn('camera');\r\n    const cam = cameraEntity.get(Camera2D);\r\n    cam.x = mapWidth / 2;\r\n    cam.y = mapHeight / 2;\r\n    cam.smoothing = 0.15;\r\n    renderer.camera = cameraEntity;\r\n\r\n    // Create UI updater\r\n    const phaseEl = document.getElementById('phase')!;\r\n    const scoreEl = document.getElementById('score')!;\r\n    const updateUI = createUIUpdater(game, phaseEl, scoreEl);\r\n\r\n    // Setup systems\r\n    setupSystems(game, config, tileSize, WIDTH, HEIGHT, updateUI);\r\n    setupCollisions(game, physics, tileSize);\r\n\r\n    // Create renderer\r\n    const renderFn = createRenderer(\r\n        game, renderer, ensureCameraEntity, canvas, config, tileSize, playerRadius,\r\n        spriteCache, getLocalClientId\r\n    );\r\n    renderer.render = renderFn;\r\n\r\n    // Connect to server with proper callbacks including onSnapshot\r\n    game.connect('brains', {\r\n        onRoomCreate() {\r\n            createMap();\r\n        },\r\n\r\n        onConnect(clientId: string) {\r\n            spawnPlayer(clientId);\r\n        },\r\n\r\n        onDisconnect(clientId: string) {\r\n            despawnPlayer(clientId);\r\n        },\r\n\r\n        /**\r\n         * CRITICAL: onSnapshot handler for late joiners\r\n         *\r\n         * When a client joins late, they receive a snapshot of the current game state.\r\n         * This callback allows us to properly synchronize client state with the server.\r\n         *\r\n         * Note: Walls are now synced (not syncNone) to ensure physics body creation\r\n         * order matches room creator. This prevents physics divergence.\r\n         */\r\n        onSnapshot(entities: Entity[]) {\r\n            // Clean up aimAngleCache - remove entries for entities not in snapshot\r\n            const validEids = new Set(entities.filter(e => e.type === 'player' && !e.destroyed).map(e => e.eid));\r\n            for (const eid of aimAngleCache.keys()) {\r\n                if (!validEids.has(eid)) {\r\n                    aimAngleCache.delete(eid);\r\n                }\r\n            }\r\n\r\n            // Find local player and center camera on them\r\n            const localId = getLocalClientId();\r\n            if (localId !== null) {\r\n                for (const entity of entities) {\r\n                    if (entity.type === 'player' && !entity.destroyed) {\r\n                        const playerComp = entity.get(Player);\r\n                        if (playerComp.clientId === localId) {\r\n                            const transform = entity.get(Transform2D);\r\n                            const camEntity = ensureCameraEntity();\r\n                            const cam = camEntity.get(Camera2D);\r\n                            cam.x = transform.x;\r\n                            cam.y = transform.y;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    });\r\n\r\n    // Enable debug UI\r\n    enableDebugUI(game);\r\n\r\n    // Handle round restart after end\r\n    // This is done client-side with a check to ensure determinism\r\n    game.addSystem(() => {\r\n        const stateEntity = getGameStateEntity(game);\r\n        if (!stateEntity) return;\r\n\r\n        const state = stateEntity.get(GamePhaseComponent);\r\n\r\n        // Check if round ended and enough time has passed (5 seconds = 100 ticks)\r\n        if (state.phase === PHASE_ENDED) {\r\n            const ticksSinceEnd = state.gameTick - state.phaseStartTick;\r\n            if (ticksSinceEnd >= 100) {  // 5 seconds at 20 tick rate\r\n                const players = getSortedPlayers(game);\r\n                if (players.length >= 2) {\r\n                    // Reset to preoutbreak\r\n                    state.phase = 1; // PHASE_PREOUTBREAK\r\n                    state.phaseStartTick = state.gameTick;\r\n                    state.sickInfectionTick = 0;\r\n                    state.outbreakTick = 0;\r\n\r\n                    // Reset all players to human and respawn at spawn area\r\n                    const spawn = config.regions.spawn;\r\n                    const spawnCenterX = (spawn.x + spawn.width / 2) * tileSize;\r\n                    const spawnCenterY = (spawn.y + spawn.height / 2) * tileSize;\r\n\r\n                    for (let i = 0; i < players.length; i++) {\r\n                        const player = players[i];\r\n                        const teamComp = player.get(TeamComponent);\r\n                        teamComp.team = TEAM_HUMAN;\r\n                        teamComp.score = 0;\r\n\r\n                        // Reset position to spawn area (deterministic based on player index)\r\n                        const transform = player.get(Transform2D);\r\n                        const body = player.get(Body2D);\r\n                        // Spread players in a grid pattern around spawn center\r\n                        const col = i % 4;\r\n                        const row = Math.floor(i / 4);\r\n                        const offsetX = (col - 1.5) * playerRadius * 3;\r\n                        const offsetY = (row - 0.5) * playerRadius * 3;\r\n                        transform.x = spawnCenterX + offsetX;\r\n                        transform.y = spawnCenterY + offsetY;\r\n                        // Stop movement\r\n                        if (body) {\r\n                            body.vx = 0;\r\n                            body.vy = 0;\r\n                        }\r\n                    }\r\n\r\n                    // Reset all furniture by destroying and recreating from config\r\n                    // This is the only reliable way since physics engine has internal state\r\n                    const furniture = [...game.query('furniture')];\r\n                    for (const f of furniture) {\r\n                        f.destroy();\r\n                    }\r\n\r\n                    // Recreate all furniture from config\r\n                    config.initialEntities.forEach((e, configIndex) => {\r\n                        const type = config.entityTypes.furniture[e.type];\r\n                        if (!type) return;\r\n\r\n                        const w = (e.width || type.width) * tileSize;\r\n                        const h = (e.height || type.height) * tileSize;\r\n                        const x = e.x * tileSize;\r\n                        const y = e.y * tileSize;\r\n                        const spriteUrlId = game.internString('spriteUrl', type.sprite);\r\n                        const angleDegrees = e.angle || 0;\r\n                        const angleRadians = (angleDegrees * Math.PI) / 180;\r\n\r\n                        const area = (w * h) / (tileSize * tileSize);\r\n                        let mass = 2 + area * 0.5;\r\n                        if (['sofa', 'couch', 'bigTable', 'bed', 'tank'].includes(e.type)) {\r\n                            mass *= 2;\r\n                        } else if (['tv', 'smallTable'].includes(e.type)) {\r\n                            mass *= 1.5;\r\n                        }\r\n\r\n                        const newFurniture = game.spawn('furniture', {\r\n                            x, y,\r\n                            angle: angleRadians,\r\n                            width: w,\r\n                            height: h,\r\n                            mass: mass,\r\n                            angularVelocity: 0\r\n                        });\r\n\r\n                        const body = newFurniture.get(Body2D);\r\n                        if (body) {\r\n                            body.width = w;\r\n                            body.height = h;\r\n                            body.mass = mass;\r\n                            body.angularVelocity = 0;\r\n                        }\r\n\r\n                        const furnitureData = newFurniture.get(FurnitureData);\r\n                        if (furnitureData) {\r\n                            furnitureData.spriteUrlId = spriteUrlId;\r\n                            furnitureData.w = w;\r\n                            furnitureData.h = h;\r\n                            furnitureData.configIndex = configIndex;\r\n                        }\r\n                    });\r\n\r\n                } else {\r\n                    // Not enough players, go back to waiting\r\n                    state.phase = PHASE_WAITING;\r\n                }\r\n            }\r\n        }\r\n    }, { phase: 'update' });\r\n\r\n    // Stale player cleanup system - removes players whose clients have disconnected\r\n    // This handles race conditions where disconnect is processed after reconnect\r\n    game.addSystem(() => {\r\n        const activeClientIds = new Set(\r\n            game.getClients().map(cid => game.internClientId(cid))\r\n        );\r\n\r\n        for (const player of game.query('player')) {\r\n            if (player.destroyed) continue;\r\n            const playerComp = player.get(Player);\r\n            if (!activeClientIds.has(playerComp.clientId)) {\r\n                aimAngleCache.delete(player.eid);\r\n                player.destroy();\r\n            }\r\n        }\r\n    }, { phase: 'update' });\r\n}\r\n\r\n// Auto-init when DOM is ready\r\nif (document.readyState === 'loading') {\r\n    document.addEventListener('DOMContentLoaded', initGame);\r\n} else {\r\n    initGame();\r\n}\r\n", "/**\r\n * Brains Game Constants\r\n *\r\n * All game constants extracted for easy tuning and reuse across modules.\r\n */\r\n\r\n// Tile and map dimensions (will be loaded from config)\r\nexport const DEFAULT_TILE_SIZE = 64;\r\n\r\n// Team types - MUST match across all files\r\nexport const TEAM_HUMAN = 0;\r\nexport const TEAM_ZOMBIE = 1;\r\nexport const TEAM_SICK = 2;\r\n\r\n// Game phase types\r\nexport const PHASE_WAITING = 0;\r\nexport const PHASE_PREOUTBREAK = 1;\r\nexport const PHASE_POSTOUTBREAK = 2;\r\nexport const PHASE_ENDED = 3;\r\n\r\n// Timing (in ticks at 20 tick rate)\r\nexport const TICK_RATE = 20;\r\nexport const TIME_PREOUTBREAK = 60 * TICK_RATE;  // 60 seconds\r\nexport const TIME_SICK = 15 * TICK_RATE;         // 15 seconds before outbreak\r\nexport const OUTBREAK_RATIO = 0.3;               // 30% of players become sick\r\n\r\n// Player speeds (from config, these are defaults)\r\nexport const DEFAULT_HUMAN_SPEED = 6.5;\r\nexport const DEFAULT_ZOMBIE_SPEED = 6;\r\nexport const DEFAULT_SICK_SPEED = 2;\r\n\r\n// Physics\r\nexport const INFECTION_DISTANCE_TILES = 1.2;  // In tile units\r\n\r\n// Player colors (for fallback)\r\nexport const HUMAN_COLOR = '#4ecdc4';\r\nexport const ZOMBIE_COLOR = '#e94560';\r\nexport const SICK_COLOR = '#ff9f43';\r\n", "/**\r\n * Brains Game Entity Definitions\r\n *\r\n * Components and entity type registrations.\r\n * Uses proper GamePhase component instead of storing state in Sprite.\r\n */\r\n\r\nimport {\r\n    Game,\r\n    Transform2D,\r\n    Body2D,\r\n    Player,\r\n    Sprite,\r\n    Camera2D,\r\n    BODY_KINEMATIC,\r\n    BODY_STATIC,\r\n    BODY_DYNAMIC,\r\n    SHAPE_CIRCLE,\r\n    SHAPE_RECT,\r\n    defineComponent,\r\n} from 'modu-engine';\r\n\r\nimport {\r\n    TEAM_HUMAN,\r\n    PHASE_WAITING,\r\n} from './constants';\r\n\r\n// ============================================\r\n// Custom Components\r\n// ============================================\r\n\r\n/**\r\n * Team component - stores player team and score\r\n */\r\nexport const TeamComponent = defineComponent('Team', {\r\n    team: TEAM_HUMAN,       // 0=human, 1=zombie, 2=sick\r\n    score: 0\r\n    // Note: aimAngle removed from sync - computed at render time to avoid floating-point desync\r\n});\r\n\r\n/**\r\n * GamePhase component - stores authoritative game state\r\n * Attached to a dedicated game-state entity for proper synchronization.\r\n * This replaces the hacky pattern of storing game state in Sprite component.\r\n */\r\nexport const GamePhaseComponent = defineComponent('GamePhase', {\r\n    phase: PHASE_WAITING,      // 0=waiting, 1=preoutbreak, 2=postoutbreak, 3=ended\r\n    gameTick: 0,\r\n    phaseStartTick: 0,\r\n    sickInfectionTick: 0,\r\n    outbreakTick: 0\r\n});\r\n\r\n/**\r\n * TileData component - stores tile ID for floor/wall rendering\r\n */\r\nexport const TileData = defineComponent('TileData', {\r\n    tileId: 0\r\n});\r\n\r\n/**\r\n * FurnitureData component - stores furniture sprite, dimensions, and config index\r\n * Config index is used to look up initial position from config.initialEntities on round restart\r\n */\r\nexport const FurnitureData = defineComponent('FurnitureData', {\r\n    spriteUrlId: 0,  // Interned string ID\r\n    w: 64,           // Pixel width (integer to avoid f32 desync)\r\n    h: 64,           // Pixel height (integer to avoid f32 desync)\r\n    configIndex: 0   // Index in config.initialEntities for position reset\r\n});\r\n\r\n// ============================================\r\n// Entity Definitions\r\n// ============================================\r\n\r\nexport function defineEntities(game: Game, tileSize: number, playerRadius: number): void {\r\n    // Game state entity - holds authoritative game phase data\r\n    // This entity syncs game state to all clients properly\r\n    game.defineEntity('game-state')\r\n        .with(GamePhaseComponent)\r\n        .register();\r\n\r\n    // Floor tiles - NO LONGER ENTITIES\r\n    // Floors are rendered directly from tilemap data in render.ts\r\n    // This saves ~1500+ entities and massive snapshot size\r\n\r\n    // Walls - physics collision only (rendered from tilemap in render.ts)\r\n    // MUST be synced to ensure physics body creation order matches between\r\n    // room creator and late joiners. Without sync, walls are created at different\r\n    // times causing physics divergence.\r\n    game.defineEntity('wall')\r\n        .with(Transform2D)\r\n        .with(Body2D, { shapeType: SHAPE_RECT, width: tileSize, height: tileSize, bodyType: BODY_STATIC })\r\n        .register();\r\n\r\n    // Furniture - dynamic physics objects (pushable)\r\n    game.defineEntity('furniture')\r\n        .with(Transform2D)\r\n        .with(Sprite, { shape: SHAPE_RECT, layer: 2, visible: false })\r\n        .with(Body2D, {\r\n            shapeType: SHAPE_RECT,\r\n            bodyType: BODY_DYNAMIC,\r\n            mass: 5,\r\n            restitution: 0.2,\r\n            friction: 0.5,\r\n            damping: 0.15,\r\n            width: tileSize,\r\n            height: tileSize\r\n        })\r\n        .with(FurnitureData)\r\n        .register();\r\n\r\n    // Player - kinematic body with team data\r\n    game.defineEntity('player')\r\n        .with(Transform2D)\r\n        .with(Sprite, { shape: SHAPE_CIRCLE, radius: playerRadius, layer: 3 })\r\n        .with(Body2D, { shapeType: SHAPE_CIRCLE, radius: playerRadius, bodyType: BODY_KINEMATIC })\r\n        .with(Player)\r\n        .with(TeamComponent)\r\n        .register();\r\n\r\n    // Camera entity - client-only, excluded from snapshots\r\n    game.defineEntity('camera')\r\n        .with(Camera2D, { smoothing: 0.5 })\r\n        .syncNone()\r\n        .register();\r\n}\r\n", "/**\r\n * Brains Game Systems\r\n *\r\n * All game systems with proper deterministic ordering using string ID comparison.\r\n * Systems are split into focused units for maintainability.\r\n */\r\n\r\nimport { Game,\r\n    Entity,\r\n    Transform2D,\r\n    Body2D,\r\n    Player,\r\n    Sprite,\r\n    Physics2DSystem,\r\n    toFixed,\r\n    toFloat,\r\n    fpMul, dSqrt } from 'modu-engine';\r\n\r\nimport {\r\n    TEAM_HUMAN,\r\n    TEAM_ZOMBIE,\r\n    TEAM_SICK,\r\n    PHASE_WAITING,\r\n    PHASE_PREOUTBREAK,\r\n    PHASE_POSTOUTBREAK,\r\n    PHASE_ENDED,\r\n    TIME_PREOUTBREAK,\r\n    TIME_SICK,\r\n    OUTBREAK_RATIO,\r\n} from './constants';\r\n\r\nimport { TeamComponent, GamePhaseComponent, FurnitureData } from './entities';\r\nimport type { GameConfig } from './types';\r\n\r\n// ============================================\r\n// Helper Functions - Deterministic Sorting\r\n// ============================================\r\n\r\n/**\r\n * Get string form of a numeric client ID\r\n */\r\nexport function getClientIdStr(game: Game, numericId: number): string {\r\n    return game.getClientIdString(numericId) || '';\r\n}\r\n\r\n/**\r\n * Compare strings for deterministic sorting\r\n * CRITICAL: This ensures identical ordering on all clients\r\n */\r\nfunction compareStrings(a: string, b: string): number {\r\n    if (a < b) return -1;\r\n    if (a > b) return 1;\r\n    return 0;\r\n}\r\n\r\n/**\r\n * Get players sorted deterministically by client ID STRING (not numeric)\r\n * This is CRITICAL for preventing divergence across clients\r\n */\r\nexport function getSortedPlayers(game: Game): Entity[] {\r\n    const players = [...game.query('player')].filter(p => !p.destroyed);\r\n\r\n    // Sort by entity ID first for stable iteration, then by client string\r\n    players.sort((a, b) => {\r\n        const aStr = getClientIdStr(game, a.get(Player).clientId);\r\n        const bStr = getClientIdStr(game, b.get(Player).clientId);\r\n        return compareStrings(aStr, bStr);\r\n    });\r\n\r\n    return players;\r\n}\r\n\r\n/**\r\n * Get the game state entity (creates if needed on room creation)\r\n */\r\nexport function getGameStateEntity(game: Game): Entity | null {\r\n    const stateEntities = [...game.query('game-state')];\r\n    return stateEntities.length > 0 ? stateEntities[0] : null;\r\n}\r\n\r\n// ============================================\r\n// Movement System\r\n// ============================================\r\n\r\nexport function createMovementSystem(\r\n    game: Game,\r\n    config: GameConfig\r\n): () => void {\r\n    const HUMAN_SPEED = config.entityTypes.player.human.speed;\r\n    const ZOMBIE_SPEED = config.entityTypes.player.zombie.speed;\r\n    const SICK_SPEED = config.entityTypes.player.sick.speed;\r\n\r\n    // Fixed-point constant for diagonal normalization\r\n    const INV_SQRT2 = 46341; // 0.7071 * 65536\r\n\r\n    return () => {\r\n        const sortedPlayers = getSortedPlayers(game);\r\n\r\n        for (const player of sortedPlayers) {\r\n            const playerComp = player.get(Player);\r\n            const teamComp = player.get(TeamComponent);\r\n            const inputData = game.world.getInput(playerComp.clientId);\r\n\r\n            if (!inputData) continue;\r\n\r\n            // Movement with WASD\r\n            if (inputData.move && (inputData.move.x !== 0 || inputData.move.y !== 0)) {\r\n                const mx = inputData.move.x > 0 ? 1 : inputData.move.x < 0 ? -1 : 0;\r\n                const my = inputData.move.y > 0 ? 1 : inputData.move.y < 0 ? -1 : 0;\r\n\r\n                // Score-based speed multiplier\r\n                const scoreMultiplier = 1 + teamComp.score / 30000;\r\n                let speed: number;\r\n\r\n                if (teamComp.team === TEAM_HUMAN) {\r\n                    speed = HUMAN_SPEED * scoreMultiplier;\r\n                } else if (teamComp.team === TEAM_ZOMBIE) {\r\n                    speed = ZOMBIE_SPEED * scoreMultiplier;\r\n                } else {\r\n                    speed = SICK_SPEED * scoreMultiplier;\r\n                }\r\n\r\n                let vx = mx * speed * 60;\r\n                let vy = my * speed * 60;\r\n\r\n                // Normalize diagonal movement using fixed-point math\r\n                if (mx !== 0 && my !== 0) {\r\n                    vx = toFloat(fpMul(toFixed(vx), INV_SQRT2));\r\n                    vy = toFloat(fpMul(toFixed(vy), INV_SQRT2));\r\n                }\r\n\r\n                player.setVelocity(vx, vy);\r\n            } else {\r\n                player.setVelocity(0, 0);\r\n            }\r\n        }\r\n    };\r\n}\r\n\r\n// ============================================\r\n// Aiming System\r\n// ============================================\r\n\r\n// Local aim angle cache - NOT synced to avoid floating-point desync\r\n// Key: entity ID, Value: aim angle in radians\r\nexport const aimAngleCache = new Map<number, number>();\r\n\r\nexport function createAimingSystem(game: Game, canvasWidth: number, canvasHeight: number): () => void {\r\n    const centerX = canvasWidth / 2;\r\n    const centerY = canvasHeight / 2;\r\n\r\n    return () => {\r\n        const sortedPlayers = getSortedPlayers(game);\r\n\r\n        for (const player of sortedPlayers) {\r\n            const playerComp = player.get(Player);\r\n            const inputData = game.world.getInput(playerComp.clientId);\r\n\r\n            if (!inputData?.aim) continue;\r\n\r\n            // Input provides raw mouse position on canvas\r\n            const aim = inputData.aim;\r\n            let mouseX = centerX;\r\n            let mouseY = centerY;\r\n\r\n            if (Array.isArray(aim)) {\r\n                mouseX = aim[0] || centerX;\r\n                mouseY = aim[1] || centerY;\r\n            } else if (typeof aim === 'object') {\r\n                mouseX = aim.x || centerX;\r\n                mouseY = aim.y || centerY;\r\n            }\r\n\r\n            // Calculate direction from screen center to mouse position\r\n            const dx = mouseX - centerX;\r\n            const dy = mouseY - centerY;\r\n\r\n            // Store in local cache (not synced) - Math.atan2 is fine here since it's render-only\r\n            aimAngleCache.set(player.eid, Math.atan2(dy, dx) + Math.PI / 2);\r\n        }\r\n    };\r\n}\r\n\r\n// ============================================\r\n// Game Phase Management System\r\n// ============================================\r\n\r\nexport function createGamePhaseSystem(\r\n    game: Game,\r\n    updateUI: () => void\r\n): () => void {\r\n    return () => {\r\n        const stateEntity = getGameStateEntity(game);\r\n        if (!stateEntity) return;\r\n\r\n        const state = stateEntity.get(GamePhaseComponent);\r\n        state.gameTick++;\r\n\r\n        const players = getSortedPlayers(game);\r\n\r\n        // Auto-start round when 2+ players join\r\n        if (state.phase === PHASE_WAITING && players.length >= 2) {\r\n            startRound(game, stateEntity);\r\n        }\r\n\r\n        // Phase transitions\r\n        const ticksInPhase = state.gameTick - state.phaseStartTick;\r\n\r\n        if (state.phase === PHASE_PREOUTBREAK) {\r\n            // Make players sick 45 seconds in (15 seconds before outbreak)\r\n            if (state.sickInfectionTick === 0 && ticksInPhase >= (TIME_PREOUTBREAK - TIME_SICK)) {\r\n                makeSomePlayersSick(game, stateEntity);\r\n            }\r\n\r\n            // Start outbreak at 60 seconds\r\n            if (ticksInPhase >= TIME_PREOUTBREAK) {\r\n                startOutbreak(game, stateEntity);\r\n            }\r\n        }\r\n\r\n        if (state.phase === PHASE_POSTOUTBREAK) {\r\n            // Check win conditions\r\n            const humans = players.filter(p => p.get(TeamComponent).team === TEAM_HUMAN).length;\r\n            const zombies = players.filter(p => p.get(TeamComponent).team === TEAM_ZOMBIE).length;\r\n\r\n            if (humans === 0 && zombies > 0) {\r\n                endRound(game, stateEntity, 'zombies');\r\n            } else if (zombies === 0 && humans > 0) {\r\n                endRound(game, stateEntity, 'humans');\r\n            }\r\n        }\r\n\r\n        updateUI();\r\n    };\r\n}\r\n\r\n// ============================================\r\n// Infection System\r\n// ============================================\r\n\r\nexport function createInfectionSystem(\r\n    game: Game,\r\n    infectionDist: number\r\n): () => void {\r\n    return () => {\r\n        const stateEntity = getGameStateEntity(game);\r\n        if (!stateEntity) return;\r\n\r\n        const state = stateEntity.get(GamePhaseComponent);\r\n        if (state.phase !== PHASE_POSTOUTBREAK) return;\r\n\r\n        const players = getSortedPlayers(game);\r\n\r\n        // Process zombies in deterministic order\r\n        for (const zombie of players) {\r\n            const zombieTeam = zombie.get(TeamComponent);\r\n            if (zombieTeam.team !== TEAM_ZOMBIE) continue;\r\n\r\n            const zombieTransform = zombie.get(Transform2D);\r\n\r\n            // Check against all humans in deterministic order\r\n            for (const human of players) {\r\n                const humanTeam = human.get(TeamComponent);\r\n                if (humanTeam.team !== TEAM_HUMAN) continue;\r\n\r\n                const humanTransform = human.get(Transform2D);\r\n                const dx = zombieTransform.x - humanTransform.x;\r\n                const dy = zombieTransform.y - humanTransform.y;\r\n                const dist = dSqrt(dx * dx + dy * dy);\r\n\r\n                if (dist < infectionDist) {\r\n                    humanTeam.team = TEAM_ZOMBIE;\r\n                    zombieTeam.score++;\r\n                }\r\n            }\r\n        }\r\n    };\r\n}\r\n\r\n// ============================================\r\n// Helper Functions for Game Phase\r\n// ============================================\r\n\r\nfunction startRound(game: Game, stateEntity: Entity): void {\r\n    const state = stateEntity.get(GamePhaseComponent);\r\n\r\n    state.phase = PHASE_PREOUTBREAK;\r\n    state.phaseStartTick = state.gameTick;\r\n    state.sickInfectionTick = 0;\r\n    state.outbreakTick = 0;\r\n\r\n    // Reset ALL players to human (in deterministic order)\r\n    const players = getSortedPlayers(game);\r\n    for (const player of players) {\r\n        const teamComp = player.get(TeamComponent);\r\n        teamComp.team = TEAM_HUMAN;\r\n        teamComp.score = 0;\r\n    }\r\n}\r\n\r\nfunction makeSomePlayersSick(game: Game, stateEntity: Entity): void {\r\n    const state = stateEntity.get(GamePhaseComponent);\r\n    const players = getSortedPlayers(game);\r\n\r\n    // Filter humans only (already sorted deterministically)\r\n    const humans = players.filter(p => p.get(TeamComponent).team === TEAM_HUMAN);\r\n    const numToInfect = Math.max(1, Math.floor(humans.length * OUTBREAK_RATIO));\r\n\r\n    // Deterministic shuffle using tick number\r\n    const shuffled = [...humans];\r\n    for (let i = shuffled.length - 1; i > 0; i--) {\r\n        const j = (state.gameTick + i) % (i + 1);\r\n        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];\r\n    }\r\n\r\n    for (let i = 0; i < numToInfect && i < shuffled.length; i++) {\r\n        shuffled[i].get(TeamComponent).team = TEAM_SICK;\r\n    }\r\n\r\n    state.sickInfectionTick = state.gameTick;\r\n}\r\n\r\nfunction startOutbreak(game: Game, stateEntity: Entity): void {\r\n    const state = stateEntity.get(GamePhaseComponent);\r\n\r\n    state.phase = PHASE_POSTOUTBREAK;\r\n    state.outbreakTick = state.gameTick;\r\n\r\n    // Convert all sick players to zombies (in deterministic order)\r\n    const players = getSortedPlayers(game);\r\n    for (const player of players) {\r\n        const teamComp = player.get(TeamComponent);\r\n        if (teamComp.team === TEAM_SICK) {\r\n            teamComp.team = TEAM_ZOMBIE;\r\n        }\r\n    }\r\n}\r\n\r\nfunction endRound(game: Game, stateEntity: Entity, winner: string): void {\r\n    const state = stateEntity.get(GamePhaseComponent);\r\n    state.phase = PHASE_ENDED;\r\n    state.phaseStartTick = state.gameTick;  // CRITICAL: Set this so the 5-second timer works\r\n}\r\n\r\n// ============================================\r\n// Collision Handlers\r\n// ============================================\r\n\r\nexport function setupCollisions(\r\n    game: Game,\r\n    physics: Physics2DSystem,\r\n    tileSize: number\r\n): void {\r\n    // Player-furniture collision: Apply push force for responsiveness\r\n    physics.onCollision('player', 'furniture', (player, furniture) => {\r\n        const playerTransform = player.get(Transform2D);\r\n        const furnitureTransform = furniture.get(Transform2D);\r\n        const furnitureBody = furniture.get(Body2D);\r\n        const playerBody = player.get(Body2D);\r\n        const furnitureData = furniture.get(FurnitureData);\r\n\r\n        if (!playerTransform || !furnitureTransform || !furnitureBody || !playerBody) return;\r\n\r\n        // Skip if player is not moving\r\n        const playerSpeed = dSqrt(playerBody.vx * playerBody.vx + playerBody.vy * playerBody.vy);\r\n        if (playerSpeed < 10) return;\r\n\r\n        // Get furniture dimensions\r\n        const furnitureWidth = furnitureData ? furnitureData.w : tileSize;\r\n        const furnitureHeight = furnitureData ? furnitureData.h : tileSize;\r\n\r\n        // Calculate collision point on furniture's edge\r\n        const relX = playerTransform.x - furnitureTransform.x;\r\n        const relY = playerTransform.y - furnitureTransform.y;\r\n\r\n        // Clamp to furniture boundaries\r\n        const halfWidth = furnitureWidth / 2;\r\n        const halfHeight = furnitureHeight / 2;\r\n        const collisionX = Math.max(-halfWidth, Math.min(halfWidth, relX));\r\n        const collisionY = Math.max(-halfHeight, Math.min(halfHeight, relY));\r\n\r\n        // Calculate push direction\r\n        const dx = furnitureTransform.x - playerTransform.x;\r\n        const dy = furnitureTransform.y - playerTransform.y;\r\n        const dist = dSqrt(dx * dx + dy * dy);\r\n\r\n        if (dist > 0.01) {\r\n            const pushStrength = Math.min(playerSpeed * 0.4, 120);\r\n            const pushX = (dx / dist) * pushStrength;\r\n            const pushY = (dy / dist) * pushStrength;\r\n\r\n            // Apply linear impulse\r\n            furnitureBody.impulseX += pushX;\r\n            furnitureBody.impulseY += pushY;\r\n\r\n            // DISABLED: Angular velocity modification causes desync\r\n            // The collision handler runs during physics step, but postPhysics\r\n            // overwrites Body2D.angularVelocity from physics body, losing our change.\r\n            // TODO: Add angularImpulse support to Body2D for proper torque application\r\n            //\r\n            // const torque = (collisionX * pushY - collisionY * pushX) * 0.00001;\r\n            // const massEffect = 3 / (furnitureBody.mass || 5);\r\n            // const adjustedTorque = torque * massEffect;\r\n            // const maxAngularVelocity = 0.5;\r\n            // const currentAngVel = furnitureBody.angularVelocity || 0;\r\n            // const newAngularVelocity = currentAngVel + adjustedTorque;\r\n            // furnitureBody.angularVelocity = Math.max(-maxAngularVelocity,\r\n            //     Math.min(maxAngularVelocity, newAngularVelocity));\r\n        }\r\n    });\r\n}\r\n\r\n// ============================================\r\n// Setup All Systems\r\n// ============================================\r\n\r\nexport function setupSystems(\r\n    game: Game,\r\n    config: GameConfig,\r\n    tileSize: number,\r\n    canvasWidth: number,\r\n    canvasHeight: number,\r\n    updateUI: () => void\r\n): void {\r\n    const infectionDist = 1.2 * tileSize;\r\n\r\n    // Add systems in proper order\r\n    game.addSystem(createMovementSystem(game, config), { phase: 'update' });\r\n    game.addSystem(createAimingSystem(game, canvasWidth, canvasHeight), { phase: 'update' });\r\n    game.addSystem(createGamePhaseSystem(game, updateUI), { phase: 'update' });\r\n    game.addSystem(createInfectionSystem(game, infectionDist), { phase: 'update' });\r\n}\r\n", "/**\r\n * Brains Game Rendering\r\n *\r\n * Factory pattern for creating the renderer function.\r\n * Handles tiles, furniture, players, and UI.\r\n */\r\n\r\nimport {\r\n    Game,\r\n    Entity,\r\n    Simple2DRenderer,\r\n    Transform2D,\r\n    Sprite,\r\n    Player,\r\n    Camera2D,\r\n} from 'modu-engine';\r\n\r\nimport {\r\n    TEAM_HUMAN,\r\n    TEAM_ZOMBIE,\r\n    TEAM_SICK,\r\n    PHASE_WAITING,\r\n    PHASE_PREOUTBREAK,\r\n    PHASE_POSTOUTBREAK,\r\n    TIME_PREOUTBREAK,\r\n    TICK_RATE,\r\n} from './constants';\r\n\r\nimport { TeamComponent, TileData, FurnitureData, GamePhaseComponent } from './entities';\r\nimport { getGameStateEntity, getSortedPlayers, aimAngleCache } from './systems';\r\nimport type { GameConfig, SpriteCache } from './types';\r\n\r\n// ============================================\r\n// Camera Update\r\n// ============================================\r\n\r\nexport function updateCamera(\r\n    game: Game,\r\n    cameraEntity: Entity,\r\n    getLocalClientId: () => number | null,\r\n    alpha: number\r\n): void {\r\n    const localId = getLocalClientId();\r\n    if (localId === null) return;\r\n\r\n    const player = game.world.getEntityByClientId(localId);\r\n    if (!player || player.destroyed) return;\r\n\r\n    const camera = cameraEntity.get(Camera2D);\r\n\r\n    // Interpolate player position\r\n    player.interpolate(alpha);\r\n    const x = player.render?.interpX ?? player.get(Transform2D).x;\r\n    const y = player.render?.interpY ?? player.get(Transform2D).y;\r\n\r\n    // Smooth camera follow\r\n    camera.x += (x - camera.x) * camera.smoothing;\r\n    camera.y += (y - camera.y) * camera.smoothing;\r\n}\r\n\r\n// ============================================\r\n// Renderer Factory\r\n// ============================================\r\n\r\nexport function createRenderer(\r\n    game: Game,\r\n    renderer: Simple2DRenderer,\r\n    getCameraEntity: () => Entity,\r\n    canvas: HTMLCanvasElement,\r\n    config: GameConfig,\r\n    tileSize: number,\r\n    playerRadius: number,\r\n    spriteCache: SpriteCache,\r\n    getLocalClientId: () => number | null\r\n): () => void {\r\n    const ctx = renderer.context;\r\n    const tileCols = spriteCache.tileCols;\r\n\r\n    function renderWithCamera(): void {\r\n        const cameraEntity = getCameraEntity();\r\n        const alpha = game.getRenderAlpha();\r\n        const camera = cameraEntity.get(Camera2D);\r\n\r\n        // Update camera to follow local player\r\n        updateCamera(game, cameraEntity, getLocalClientId, alpha);\r\n\r\n        const camX = camera.x;\r\n        const camY = camera.y;\r\n\r\n        // Clear canvas\r\n        ctx.fillStyle = '#0a0e14';\r\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\r\n\r\n        // Apply camera transform\r\n        ctx.save();\r\n        ctx.translate(canvas.width / 2 - camX, canvas.height / 2 - camY);\r\n        ctx.imageSmoothingEnabled = false;\r\n\r\n        // Render floor tiles directly from tilemap (NOT as entities - saves ~1500 entities)\r\n        const floorLayer = config.map.layers.find(l => l.name === 'floor' || l.name.includes('floor'));\r\n        if (floorLayer && spriteCache.tilesheetImg) {\r\n            for (let i = 0; i < floorLayer.data.length; i++) {\r\n                const tileId = floorLayer.data[i];\r\n                if (tileId !== 0) {\r\n                    const tx = (i % config.map.width) * tileSize;\r\n                    const ty = Math.floor(i / config.map.width) * tileSize;\r\n                    const srcTileId = tileId - 1;\r\n                    const srcX = (srcTileId % tileCols) * tileSize;\r\n                    const srcY = Math.floor(srcTileId / tileCols) * tileSize;\r\n                    ctx.drawImage(spriteCache.tilesheetImg, srcX, srcY, tileSize, tileSize, tx, ty, tileSize, tileSize);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Render wall tiles directly from tilemap (NOT as entities)\r\n        const wallLayer = config.map.layers.find(l => l.name === 'walls' || l.name === 'collision');\r\n        if (wallLayer && spriteCache.tilesheetImg) {\r\n            for (let i = 0; i < wallLayer.data.length; i++) {\r\n                const tileId = wallLayer.data[i];\r\n                if (tileId !== 0) {\r\n                    const tx = (i % config.map.width) * tileSize;\r\n                    const ty = Math.floor(i / config.map.width) * tileSize;\r\n                    const srcTileId = tileId - 1;\r\n                    const srcX = (srcTileId % tileCols) * tileSize;\r\n                    const srcY = Math.floor(srcTileId / tileCols) * tileSize;\r\n                    ctx.drawImage(spriteCache.tilesheetImg, srcX, srcY, tileSize, tileSize, tx, ty, tileSize, tileSize);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Get dynamic entities (furniture, players) and sort by layer\r\n        const entities = Array.from(game.getAllEntities()).filter(e =>\r\n            !e.destroyed && (e.type === 'furniture' || e.type === 'player')\r\n        );\r\n        entities.sort((a, b) => {\r\n            const aLayer = a.has(Sprite) ? a.get(Sprite).layer : 0;\r\n            const bLayer = b.has(Sprite) ? b.get(Sprite).layer : 0;\r\n            return aLayer - bLayer;\r\n        });\r\n\r\n        // Render dynamic entities only\r\n        for (const entity of entities) {\r\n            if (entity.destroyed) continue;\r\n\r\n            // Interpolate position for smooth rendering\r\n            entity.interpolate(alpha);\r\n            const pos = { x: entity.render.interpX, y: entity.render.interpY };\r\n            const type = entity.type;\r\n\r\n            // Furniture\r\n            if (type === 'furniture' && entity.has(FurnitureData)) {\r\n                renderFurniture(ctx, game, entity, pos, spriteCache);\r\n                continue;\r\n            }\r\n\r\n            // Players\r\n            if (type === 'player' && entity.has(TeamComponent)) {\r\n                renderPlayer(ctx, game, entity, pos, config, playerRadius, spriteCache);\r\n            }\r\n        }\r\n\r\n        ctx.restore();\r\n    }\r\n\r\n    return renderWithCamera;\r\n}\r\n\r\n// ============================================\r\n// Individual Render Functions\r\n// ============================================\r\n\r\nfunction renderTile(\r\n    ctx: CanvasRenderingContext2D,\r\n    entity: Entity,\r\n    pos: { x: number; y: number },\r\n    tileSize: number,\r\n    spriteCache: SpriteCache,\r\n    tileCols: number,\r\n    fallbackColor: string\r\n): void {\r\n    const tileData = entity.get(TileData);\r\n    const tilesheetImg = spriteCache.tilesheetImg;\r\n\r\n    if (tilesheetImg && tileData.tileId) {\r\n        const tileId = tileData.tileId - 1;\r\n        const srcX = (tileId % tileCols) * tileSize;\r\n        const srcY = Math.floor(tileId / tileCols) * tileSize;\r\n        ctx.drawImage(\r\n            tilesheetImg,\r\n            srcX, srcY, tileSize, tileSize,\r\n            pos.x - tileSize / 2, pos.y - tileSize / 2, tileSize, tileSize\r\n        );\r\n    } else {\r\n        ctx.fillStyle = fallbackColor;\r\n        ctx.fillRect(pos.x - tileSize / 2, pos.y - tileSize / 2, tileSize, tileSize);\r\n    }\r\n}\r\n\r\nfunction renderFurniture(\r\n    ctx: CanvasRenderingContext2D,\r\n    game: Game,\r\n    entity: Entity,\r\n    pos: { x: number; y: number },\r\n    spriteCache: SpriteCache\r\n): void {\r\n    const furnitureData = entity.get(FurnitureData);\r\n    const transform = entity.get(Transform2D);\r\n    const spriteUrl = game.getString('spriteUrl', furnitureData.spriteUrlId);\r\n    const sprite = spriteCache.sprites.get(spriteUrl || '');\r\n    const w = furnitureData.w;\r\n    const h = furnitureData.h;\r\n    const angle = transform ? transform.angle : 0;\r\n\r\n    ctx.save();\r\n    ctx.translate(pos.x, pos.y);\r\n    if (angle) ctx.rotate(angle);\r\n\r\n    if (sprite) {\r\n        ctx.drawImage(sprite, -w / 2, -h / 2, w, h);\r\n    } else {\r\n        ctx.fillStyle = '#7f8c8d';\r\n        ctx.fillRect(-w / 2, -h / 2, w, h);\r\n    }\r\n\r\n    ctx.restore();\r\n}\r\n\r\nfunction renderPlayer(\r\n    ctx: CanvasRenderingContext2D,\r\n    game: Game,\r\n    entity: Entity,\r\n    pos: { x: number; y: number },\r\n    config: GameConfig,\r\n    playerRadius: number,\r\n    spriteCache: SpriteCache\r\n): void {\r\n    const teamComp = entity.get(TeamComponent);\r\n    const teamNum = teamComp.team;\r\n\r\n    // Get team configuration\r\n    const teamName = teamNum === TEAM_ZOMBIE ? 'zombie' : teamNum === TEAM_SICK ? 'sick' : 'human';\r\n    const teamConfig = config.entityTypes.player[teamName];\r\n    const sprite = spriteCache.sprites.get(teamConfig?.sprite || '');\r\n    const color = teamConfig?.color || '#fff';\r\n    // Get aim angle from local cache (not synced to avoid floating-point desync)\r\n    const aimAngle = aimAngleCache.get(entity.eid) || 0;\r\n\r\n    ctx.save();\r\n    ctx.translate(pos.x, pos.y);\r\n    ctx.rotate(aimAngle);\r\n\r\n    if (sprite) {\r\n        ctx.drawImage(sprite, -playerRadius, -playerRadius, playerRadius * 2, playerRadius * 2);\r\n    } else {\r\n        // Fallback: colored circle\r\n        ctx.beginPath();\r\n        ctx.arc(0, 0, playerRadius, 0, Math.PI * 2);\r\n        ctx.fillStyle = color;\r\n        ctx.fill();\r\n        ctx.strokeStyle = '#fff';\r\n        ctx.lineWidth = 2;\r\n        ctx.stroke();\r\n\r\n        // Direction indicator\r\n        ctx.fillStyle = '#fff';\r\n        ctx.beginPath();\r\n        ctx.moveTo(playerRadius * 0.5, 0);\r\n        ctx.lineTo(playerRadius * 0.8, -playerRadius * 0.2);\r\n        ctx.lineTo(playerRadius * 0.8, playerRadius * 0.2);\r\n        ctx.fill();\r\n    }\r\n\r\n    ctx.restore();\r\n}\r\n\r\n// ============================================\r\n// UI Update Function\r\n// ============================================\r\n\r\nexport function createUIUpdater(\r\n    game: Game,\r\n    phaseEl: HTMLElement,\r\n    scoreEl: HTMLElement\r\n): () => void {\r\n    return () => {\r\n        const stateEntity = getGameStateEntity(game);\r\n        if (!stateEntity) return;\r\n\r\n        const state = stateEntity.get(GamePhaseComponent);\r\n        const players = getSortedPlayers(game);\r\n\r\n        const humans = players.filter(p => p.get(TeamComponent).team === TEAM_HUMAN).length;\r\n        const zombies = players.filter(p => p.get(TeamComponent).team === TEAM_ZOMBIE).length;\r\n        const sick = players.filter(p => p.get(TeamComponent).team === TEAM_SICK).length;\r\n\r\n        const ticksInPhase = state.gameTick - state.phaseStartTick;\r\n\r\n        if (state.phase === PHASE_WAITING) {\r\n            phaseEl.textContent = 'Waiting for players...';\r\n        } else if (state.phase === PHASE_PREOUTBREAK) {\r\n            const secondsLeft = Math.max(0, Math.ceil((TIME_PREOUTBREAK - ticksInPhase) / TICK_RATE));\r\n            phaseEl.innerHTML = `Pre-outbreak: ${secondsLeft}s | <span class=\"team-humans\">Humans: ${humans}</span> | Sick: ${sick}`;\r\n        } else if (state.phase === PHASE_POSTOUTBREAK) {\r\n            phaseEl.innerHTML = `<span class=\"team-humans\">Humans: ${humans}</span> | <span class=\"team-zombies\">Zombies: ${zombies}</span>`;\r\n        } else {\r\n            phaseEl.textContent = 'Round ended!';\r\n        }\r\n    };\r\n}\r\n\r\n// ============================================\r\n// Sprite Loading\r\n// ============================================\r\n\r\nexport async function loadSprites(\r\n    config: GameConfig,\r\n    spriteCache: SpriteCache\r\n): Promise<void> {\r\n    const loadSprite = (url: string): Promise<HTMLImageElement | null> => {\r\n        if (spriteCache.sprites.has(url)) {\r\n            return Promise.resolve(spriteCache.sprites.get(url)!);\r\n        }\r\n\r\n        return new Promise((resolve) => {\r\n            const img = new Image();\r\n            img.crossOrigin = 'anonymous';\r\n            img.onload = () => {\r\n                spriteCache.sprites.set(url, img);\r\n                resolve(img);\r\n            };\r\n            img.onerror = () => {\r\n                console.warn('[Brains] Failed to load:', url);\r\n                resolve(null);\r\n            };\r\n            img.src = url;\r\n        });\r\n    };\r\n\r\n    // Load tilesheet\r\n    const tilesheetInfo = config.map.tilesets?.[0];\r\n    if (tilesheetInfo) {\r\n        const img = await loadSprite(tilesheetInfo.localImage);\r\n        spriteCache.tilesheetImg = img;\r\n        spriteCache.tileCols = tilesheetInfo.columns || 1;\r\n    }\r\n\r\n    // Load player sprites\r\n    await Promise.all([\r\n        loadSprite(config.entityTypes.player.human.sprite),\r\n        loadSprite(config.entityTypes.player.zombie.sprite),\r\n        loadSprite(config.entityTypes.player.sick.sprite)\r\n    ]);\r\n\r\n    // Load furniture sprites (background)\r\n    const furniturePromises = Object.values(config.entityTypes.furniture || {}).map(f => {\r\n        if (f.sprite) return loadSprite(f.sprite);\r\n        return Promise.resolve(null);\r\n    });\r\n    await Promise.all(furniturePromises);\r\n}\r\n"],
  "mappings": "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",
  "names": ["import_modu_engine", "game", "tileSize", "playerRadius", "import_modu_engine", "game", "config", "mouseX", "mouseY", "physics", "tileSize", "import_modu_engine", "game", "cameraEntity", "getLocalClientId", "renderer", "canvas", "config", "tileSize", "playerRadius", "spriteCache", "game", "spriteCache", "config", "playerRadius", "cam"]
}
