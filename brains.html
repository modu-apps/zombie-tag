<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Brains - Zombie Tag</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #0a0e14;
            color: #e0e0e0;
            font-family: system-ui, -apple-system, sans-serif;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        canvas { border: 2px solid #1a1f2e; background: #16213e; cursor: crosshair; }
        #ui {
            position: fixed; top: 20px; left: 20px;
            background: rgba(0, 0, 0, 0.8); padding: 15px; border-radius: 8px;
            backdrop-filter: blur(5px); min-width: 200px;
        }
        #ui h2 { color: #4ecdc4; font-size: 18px; margin-bottom: 10px; }
        .phase { color: #ffd700; font-weight: bold; margin: 8px 0; }
        .team-humans { color: #4ecdc4; }
        .team-zombies { color: #e94560; }
        #loading { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #4ecdc4; }
    </style>
</head>
<body>
    <div id="loading">Loading game...</div>
    <canvas id="game"></canvas>
    <div id="ui" style="display: none;">
        <h2>Brains</h2>
        <div class="phase" id="phase">Waiting...</div>
        <div id="score"></div>
    </div>

<script>
// ====================================================================
// MIGRATED TO NEW ECS API (2025-01-05)
// Original: Old Entity2D API with Modu.init()
// New: ECS API with createGame() and plugins
// ====================================================================

// Load SDK based on environment (EXACT same as modu-cell)
(function () {
    const isLocalhost = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
    const script = document.createElement('script');

    if (isLocalhost) {
        script.src = 'http://localhost:3001/dist/modu.iife.js?v=dev';
    } else {
        // Use production CDN with dynamic version for cache busting
        const version = Date.now();
        script.src = `https://cdn.moduengine.com/modu.iife.js?v=${version}`;
    }

    script.onload = initGame;
    document.head.appendChild(script);
})();

async function initGame() {
    // Load game.json
    const res = await fetch('brains.json');
    const cfg = (await res.json()).game;
    const TILE = cfg.metadata.tileSize;
    const MAP_W = cfg.map.width * TILE, MAP_H = cfg.map.height * TILE;

    const canvas = document.getElementById('game');
    canvas.width = Math.min(MAP_W, window.innerWidth - 40);
    canvas.height = Math.min(MAP_H, window.innerHeight - 40);

    // NEW ECS API: createGame() instead of Modu.init()
    const game = createGame();

    // NEW: Add plugins instead of direct instantiation
    const physics = game.addPlugin(Physics2DSystem, { gravity: { x: 0, y: 0 } });
    const renderer = game.addPlugin(Simple2DRenderer, canvas);
    window.game = game;

    // Camera state (simple object, not an entity - IIFE doesn't support Camera2D entity well)
    const camera = {
        x: MAP_W / 2,
        y: MAP_H / 2,
        zoom: 1.0,
        smoothing: 0.15
    };

    // Catch-up synchronization flag (like snake game)
    // When a late client joins, they receive a snapshot and simulate catch-up frames.
    // During catch-up, we skip spawning to prevent entity ID divergence.
    let isInCatchUp = false;

    // Hash function for deterministic values (like cell-eater)
    function hashString(str) {
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            const char = str.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash; // Convert to 32-bit integer
        }
        return hash >>> 0; // Ensure positive
    }

    // ====================================================================
    // DEFINE CUSTOM COMPONENTS (NEW ECS API)
    // Components hold all game state - must be defined before entities
    // Note: Use plain numbers or { type: 'f32', default: 0 } only
    // ====================================================================

    // Team types: 0=human, 1=zombie, 2=sick
    const TEAM_HUMAN = 0;
    const TEAM_ZOMBIE = 1;
    const TEAM_SICK = 2;

    const TeamComponent = defineComponent('Team', {
        team: 0,  // 0=human, 1=zombie, 2=sick
        score: 0,
        aimAngle: { type: 'f32', default: 0 }
    });

    const TileData = defineComponent('TileData', {
        tileId: 0
    });

    const FurnitureData = defineComponent('FurnitureData', {
        spriteUrlId: 0,  // Interned string ID
        w: 64,           // i32 - used in collision calculations
        h: 64,           // i32 - used in collision calculations
        angle: 0,        // i32 - initial angle in degrees (render uses Transform2D.angle)
        initialX: { type: 'f32', default: 0 },  // Initial position for round reset
        initialY: { type: 'f32', default: 0 },
        initialAngle: { type: 'f32', default: 0 }
    });

    // GameState component - replaces hacky sprite-based storage
    // This ensures game state survives player disconnections
    const GameStateComponent = defineComponent('GameState', {
        phase: 0,              // 0=waiting, 1=preoutbreak, 2=postoutbreak, 3=ended
        phaseStartTick: 0,
        sickInfectionTick: 0,
        outbreakTick: 0,
        gameTick: 0
    });

    // Phase constants for GameState
    const PHASE_WAITING = 0;
    const PHASE_PREOUTBREAK = 1;
    const PHASE_POSTOUTBREAK = 2;
    const PHASE_ENDED = 3;

    // Game constants
    const HUMAN_SPEED = cfg.entityTypes.player.human.speed;
    const ZOMBIE_SPEED = cfg.entityTypes.player.zombie.speed;
    const SICK_SPEED = cfg.entityTypes.player.sick.speed;
    const PLAYER_RADIUS = cfg.entityTypes.player.human.width * TILE;  // Use full width as diameter
    const INFECTION_DIST = 1.2 * TILE;

    // Sprites
    const sprites = new Map();
    async function loadSprite(url) {
        if (sprites.has(url)) return sprites.get(url);
        return new Promise((resolve) => {
            const img = new Image();
            img.crossOrigin = 'anonymous';
            img.onload = () => { sprites.set(url, img); resolve(img); };
            img.onerror = () => { console.warn('[Brains] Failed to load:', url); resolve(null); };
            img.src = url;
        });
    }

    // Load tilesheet
    const tilesheetInfo = cfg.map.tilesets?.[0];
    const tilesheetImg = tilesheetInfo ? await loadSprite(tilesheetInfo.localImage) : null;
    const TILE_COLS = tilesheetInfo?.columns || 1;

    // Preload player sprites
    await Promise.all([
        loadSprite(cfg.entityTypes.player.human.sprite),
        loadSprite(cfg.entityTypes.player.zombie.sprite),
        loadSprite(cfg.entityTypes.player.sick.sprite)
    ]);

    // Load furniture sprites (background)
    Object.values(cfg.entityTypes.furniture || {}).forEach(f => {
        if (f.sprite) loadSprite(f.sprite);
    });

    document.getElementById('loading').style.display = 'none';
    document.getElementById('ui').style.display = 'block';

    // ====================================================================
    // DEFINE ENTITY TYPES (NEW ECS API)
    // ====================================================================

    // Floor tiles - visual only, sensor body
    game.defineEntity('_floor')
        .with(Transform2D)
        .with(Sprite, { shape: SHAPE_RECT, width: TILE, height: TILE, layer: 0, visible: false })
        .with(Body2D, { shapeType: SHAPE_RECT, width: TILE, height: TILE, bodyType: BODY_STATIC, isSensor: true })
        .with(TileData)
        .register();

    // Walls - solid collision
    game.defineEntity('wall')
        .with(Transform2D)
        .with(Sprite, { shape: SHAPE_RECT, width: TILE, height: TILE, layer: 1, visible: false })
        .with(Body2D, { shapeType: SHAPE_RECT, width: TILE, height: TILE, bodyType: BODY_STATIC })
        .with(TileData)
        .register();

    // Furniture - dynamic physics objects (pushable)
    game.defineEntity('furniture')
        .with(Transform2D)
        .with(Sprite, { shape: SHAPE_RECT, layer: 2, visible: false })
        .with(Body2D, {
            shapeType: SHAPE_RECT,
            bodyType: BODY_DYNAMIC,  // Changed from STATIC to DYNAMIC for pushable furniture
            mass: 5,                 // Default mass, will be overridden per furniture type
            restitution: 0.2,        // Slight bounce when hit
            friction: 0.5,           // Some friction for realistic pushing
            damping: 0.15,           // Reduced damping for more realistic movement
            width: TILE,             // Default width, will be overridden
            height: TILE             // Default height, will be overridden
        })
        .with(FurnitureData)
        .register();

    // Player - kinematic body with team data
    game.defineEntity('player')
        .with(Transform2D)
        .with(Sprite, { shape: SHAPE_CIRCLE, radius: PLAYER_RADIUS, layer: 3 })
        .with(Body2D, { shapeType: SHAPE_CIRCLE, radius: PLAYER_RADIUS, bodyType: BODY_KINEMATIC })
        .with(Player)
        .with(TeamComponent)
        .register();


    // Game state entity - stores game phase info independent of players
    game.defineEntity('_game-state')
        .with(GameStateComponent)
        .register();

    // Game state constants
    const TICK_RATE = 20;
    const TIME_PREOUTBREAK = 60 * TICK_RATE;
    const TIME_SICK = 15 * TICK_RATE;
    const OUTBREAK_RATIO = 0.3;

    // Game state entity reference (will be set after spawn)
    let gameStateEntity = null;

    // Get the game state entity (creates if needed for authority)
    function getGameState() {
        // Try to find existing game state entity
        const stateEntities = Array.from(game.query('_game-state'));
        if (stateEntities.length > 0) {
            gameStateEntity = stateEntities[0];
            return gameStateEntity.get(GameStateComponent);
        }
        return null;
    }

    // Helper to get phase name for UI
    function getPhaseName(phase) {
        switch (phase) {
            case PHASE_WAITING: return 'waiting';
            case PHASE_PREOUTBREAK: return 'preoutbreak';
            case PHASE_POSTOUTBREAK: return 'postoutbreak';
            case PHASE_ENDED: return 'ended';
            default: return 'unknown';
        }
    }

    // ====================================================================
    // CAMERA UPDATE FUNCTION
    // ====================================================================
    function updateCamera(alpha) {
        const localClientId = game.localClientId;
        if (!localClientId) return;

        const localPlayer = game.getEntityByClientId(localClientId);
        if (!localPlayer || localPlayer.destroyed) return;

        // Use interpolated position for smoother camera movement
        localPlayer.interpolate(alpha);
        const targetX = localPlayer.render.interpX;
        const targetY = localPlayer.render.interpY;

        // Apply smoothing
        camera.x += (targetX - camera.x) * camera.smoothing;
        camera.y += (targetY - camera.y) * camera.smoothing;
    }

    // ====================================================================
    // CUSTOM RENDERER (Override Simple2DRenderer render method)
    // ====================================================================
    const originalRender = renderer.render.bind(renderer);
    renderer.render = function() {
        const ctx = renderer.context;
        const alpha = game.getRenderAlpha();

        // Update camera
        updateCamera(alpha);

        // Get camera position for rendering
        const camX = camera.x;
        const camY = camera.y;
        const zoom = camera.zoom;

        // Find local player for interpolation tracking
        const localClientId = game.localClientId;
        let localPlayer = null;
        if (localClientId) {
            localPlayer = game.getEntityByClientId(localClientId);
        }

        // Clear canvas
        ctx.fillStyle = '#0a0e14';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Apply camera transform with zoom
        ctx.save();
        ctx.translate(canvas.width / 2, canvas.height / 2);
        ctx.scale(zoom, zoom);
        ctx.translate(-camX, -camY);
        ctx.imageSmoothingEnabled = false;

        // Render all entities with custom drawing
        const entities = Array.from(game.getAllEntities()).filter(e => !e.destroyed);

        // Sort by layer for proper rendering order
        entities.sort((a, b) => {
            const aLayer = a.has(Sprite) ? a.get(Sprite).layer : 0;
            const bLayer = b.has(Sprite) ? b.get(Sprite).layer : 0;
            return aLayer - bLayer;
        });

        for (const entity of entities) {
            if (entity.destroyed) continue;

            // Skip entities without Transform2D (like _game-state)
            if (!entity.has(Transform2D)) continue;

            // Interpolate position (skip if already interpolated for camera)
            if (entity !== localPlayer) {
                entity.interpolate(alpha);
            }
            const pos = { x: entity.render.interpX, y: entity.render.interpY };

            // Custom drawing per entity type
            const type = entity.type;

            // Floor tiles
            if (type === '_floor' && entity.has(TileData)) {
                const tileData = entity.get(TileData);
                if (tilesheetImg && tileData.tileId) {
                    const tileId = tileData.tileId - 1;
                    const srcX = (tileId % TILE_COLS) * TILE;
                    const srcY = Math.floor(tileId / TILE_COLS) * TILE;
                    ctx.drawImage(tilesheetImg, srcX, srcY, TILE, TILE, pos.x - TILE / 2, pos.y - TILE / 2, TILE, TILE);
                } else {
                    ctx.fillStyle = '#1a2332';
                    ctx.fillRect(pos.x - TILE / 2, pos.y - TILE / 2, TILE, TILE);
                }
                continue;
            }

            // Walls
            if (type === 'wall' && entity.has(TileData)) {
                const tileData = entity.get(TileData);
                if (tilesheetImg && tileData.tileId) {
                    const tileId = tileData.tileId - 1;
                    const srcX = (tileId % TILE_COLS) * TILE;
                    const srcY = Math.floor(tileId / TILE_COLS) * TILE;
                    ctx.drawImage(tilesheetImg, srcX, srcY, TILE, TILE, pos.x - TILE / 2, pos.y - TILE / 2, TILE, TILE);
                } else {
                    ctx.fillStyle = '#2c3e50';
                    ctx.fillRect(pos.x - TILE / 2, pos.y - TILE / 2, TILE, TILE);
                }
                continue;
            }

            // Furniture
            if (type === 'furniture' && entity.has(FurnitureData)) {
                const furnitureData = entity.get(FurnitureData);
                const transform = entity.get(Transform2D);
                const spriteUrl = game.getString('spriteUrl', furnitureData.spriteUrlId);
                const sprite = sprites.get(spriteUrl);
                const w = furnitureData.w;
                const h = furnitureData.h;
                // Use Transform2D angle (in radians, updated by physics) instead of static FurnitureData angle
                const angle = transform ? transform.angle : 0;

                ctx.save();
                ctx.translate(pos.x, pos.y);
                if (angle) ctx.rotate(angle); // Already in radians from Transform2D
                if (sprite) {
                    ctx.drawImage(sprite, -w / 2, -h / 2, w, h);
                } else {
                    ctx.fillStyle = '#7f8c8d';
                    ctx.fillRect(-w / 2, -h / 2, w, h);
                }
                ctx.restore();
                continue;
            }

            // Players
            if (type === 'player' && entity.has(TeamComponent)) {
                const teamComp = entity.get(TeamComponent);
                const teamNum = teamComp.team;
                // Convert team number to string: 0=human, 1=zombie, 2=sick
                const teamName = teamNum === TEAM_ZOMBIE ? 'zombie' : teamNum === TEAM_SICK ? 'sick' : 'human';
                const teamConfig = cfg.entityTypes.player[teamName];
                const sprite = sprites.get(teamConfig?.sprite);
                const color = teamConfig?.color || '#fff';
                const aimAngle = teamComp.aimAngle;

                ctx.save();
                ctx.translate(pos.x, pos.y);
                ctx.rotate(aimAngle);

                if (sprite) {
                    ctx.drawImage(sprite, -PLAYER_RADIUS, -PLAYER_RADIUS, PLAYER_RADIUS * 2, PLAYER_RADIUS * 2);
                } else {
                    // Fallback: colored circle
                    ctx.beginPath();
                    ctx.arc(0, 0, PLAYER_RADIUS, 0, Math.PI * 2);
                    ctx.fillStyle = color;
                    ctx.fill();
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    // Direction indicator
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.moveTo(PLAYER_RADIUS * 0.5, 0);
                    ctx.lineTo(PLAYER_RADIUS * 0.8, -PLAYER_RADIUS * 0.2);
                    ctx.lineTo(PLAYER_RADIUS * 0.8, PLAYER_RADIUS * 0.2);
                    ctx.fill();
                }

                ctx.restore();
            }
        }

        ctx.restore();
    };

    // ====================================================================
    // INPUT SYSTEM (NEW ECS API)
    // ====================================================================
    // Track mouse position for aim conversion
    let mouseX = canvas.width / 2;
    let mouseY = canvas.height / 2;
    canvas.addEventListener('mousemove', (e) => {
        const rect = canvas.getBoundingClientRect();
        mouseX = e.clientX - rect.left;
        mouseY = e.clientY - rect.top;
    });

    const input = game.addPlugin(InputPlugin, canvas);
    input.action('move', { type: 'vector', bindings: ['keys:wasd', 'keys:arrows'] });
    // Convert mouse to world coordinates BEFORE sending (so all clients get same world coords)
    input.action('aim', {
        type: 'vector',
        bindings: [() => {
            // Convert canvas coords to world coords using local camera
            // This gets sent to all clients as world coordinates
            const worldX = Math.round((mouseX - canvas.width / 2) / camera.zoom + camera.x);
            const worldY = Math.round((mouseY - canvas.height / 2) / camera.zoom + camera.y);
            return { x: worldX, y: worldY };
        }]
    });

    // ====================================================================
    // CAMERA SYSTEM - Now handled directly in renderer.render() above
    // ====================================================================
    // Removed: Camera update moved into custom renderer for proper timing

    // ====================================================================
    // CALLBACKS (Migrated to new spawn pattern)
    // ====================================================================
    const callbacks = {
        onRoomCreate() {
            // Create floor tiles
            const floorLayer = cfg.map.layers.find(l => l.name === 'floor' || l.name.includes('floor'));
            if (floorLayer) {
                for (let i = 0; i < floorLayer.data.length; i++) {
                    if (floorLayer.data[i] !== 0) {
                        const tx = (i % cfg.map.width) * TILE + TILE / 2;
                        const ty = Math.floor(i / cfg.map.width) * TILE + TILE / 2;
                        game.spawn('_floor', { x: tx, y: ty, tileId: floorLayer.data[i] });
                    }
                }
            }

            // Create walls
            const wallLayer = cfg.map.layers.find(l => l.name === 'walls' || l.name === 'collision');
            if (wallLayer) {
                for (let i = 0; i < wallLayer.data.length; i++) {
                    if (wallLayer.data[i] !== 0) {
                        const tx = (i % cfg.map.width) * TILE + TILE / 2;
                        const ty = Math.floor(i / cfg.map.width) * TILE + TILE / 2;
                        game.spawn('wall', { x: tx, y: ty, tileId: wallLayer.data[i] });
                    }
                }
            }

            // Create furniture
            cfg.initialEntities.forEach(e => {
                const type = cfg.entityTypes.furniture[e.type];
                const w = (e.width || type.width) * TILE;
                const h = (e.height || type.height) * TILE;
                const x = e.x * TILE;
                const y = e.y * TILE;
                const spriteUrlId = game.internString('spriteUrl', type.sprite);
                const angleDegrees = e.angle || 0;
                const angleRadians = (angleDegrees * Math.PI) / 180; // Convert degrees to radians for Transform2D

                // Calculate mass based on furniture size (larger = heavier)
                const area = (w * h) / (TILE * TILE); // Area in tiles
                let mass = 2 + area * 0.5; // Base mass + size factor

                // Make certain furniture types heavier
                if (e.type === 'sofa' || e.type === 'couch' || e.type === 'bigTable' || e.type === 'bed' || e.type === 'tank') {
                    mass *= 2; // These are extra heavy
                } else if (e.type === 'tv' || e.type === 'smallTable') {
                    mass *= 1.5; // Medium weight
                }
                // Small chairs and boxes remain lighter (default mass calculation)

                const furniture = game.spawn('furniture', {
                    x, y,
                    angle: angleRadians,  // Set Transform2D angle in radians
                    spriteUrlId,
                    w: w | 0,            // FurnitureData dimensions (i32)
                    h: h | 0,
                    width: w,            // Body2D width for physics
                    height: h,           // Body2D height for physics
                    mass: mass,          // Dynamic mass based on furniture type/size
                    angularVelocity: 0   // Initialize angular velocity
                });

                // Ensure Body2D dimensions and physics properties are properly set
                const body = furniture.get(Body2D);
                if (body) {
                    body.width = w;
                    body.height = h;
                    body.mass = mass;
                    body.angularVelocity = 0; // Initialize angular velocity
                    // Log the body type to verify it's dynamic
                    console.log(`Created furniture: type=${e.type}, bodyType=${body.bodyType} (should be ${BODY_DYNAMIC} for dynamic), mass=${mass.toFixed(2)}`);
                }

                // Store rendering dimensions in FurnitureData (convert to integers for i32 fields)
                const furnitureData = furniture.get(FurnitureData);
                if (furnitureData) {
                    furnitureData.angle = angleDegrees | 0;
                    furnitureData.w = w | 0;
                    furnitureData.h = h | 0;
                    // Store initial state for round reset (synced to all clients)
                    furnitureData.initialX = x;
                    furnitureData.initialY = y;
                    furnitureData.initialAngle = angleRadians;
                    console.log(`Stored initial furniture pos: (${x}, ${y}), angle: ${angleRadians}`);
                }
            });

            // Spawn game state entity (authority creates it)
            gameStateEntity = game.spawn('_game-state', {
                phase: PHASE_WAITING,
                phaseStartTick: 0,
                sickInfectionTick: 0,
                outbreakTick: 0,
                gameTick: 0
            });
        },

        onConnect(clientId) {
            const spawn = cfg.regions.spawn;
            // Use hash-based spawn for determinism (like cell-eater)
            const hash = hashString(clientId);
            const spawnWidth = spawn.width * TILE;
            const spawnHeight = spawn.height * TILE;
            const spawnBaseX = spawn.x * TILE;
            const spawnBaseY = spawn.y * TILE;

            // Deterministic position from hash
            const x = spawnBaseX + ((hash >>> 0) % spawnWidth);
            const y = spawnBaseY + ((hash >>> 16 ^ hash) % spawnHeight);

            const player = game.spawn('player', {
                x, y,
                clientId,
                team: TEAM_HUMAN,  // Use numeric constant
                score: 0,
                aimAngle: 0
            });
        },

        onDisconnect(clientId) {
            game.getEntityByClientId(clientId)?.destroy();
        },

        // Catch-up synchronization for late joiners (like snake)
        onSnapshot(entities) {
            // Mark that we're in catch-up mode
            isInCatchUp = true;
            console.log(`[onSnapshot] Entering catch-up mode at frame ${game.frame}, ${entities.length} entities`);

            // Find the game state entity from snapshot
            for (const entity of entities) {
                if (entity.type === '_game-state' && !entity.destroyed) {
                    gameStateEntity = entity;
                    break;
                }
            }

            // Clear catch-up flag after synchronous catch-up completes
            setTimeout(() => {
                console.log(`[onSnapshot] Exiting catch-up mode at frame ${game.frame}`);
                isInCatchUp = false;
            }, 0);
        }
    };

    // ====================================================================
    // GAME SYSTEMS (NEW ECS API - replaces onTick)
    // ====================================================================

    // Movement and aiming system
    game.addSystem(() => {
        for (const player of game.query('player')) {
            const playerComp = player.get(Player);
            const teamComp = player.get(TeamComponent);
            const transform = player.get(Transform2D);
            const inputData = game.world.getInput(playerComp.clientId);

            // Camera update is now in render loop (see renderer.render above)

            if (!inputData) continue;

            // Movement with WASD (using same approach as 2d-shooter)
            if (inputData.move && (inputData.move.x !== 0 || inputData.move.y !== 0)) {
                const mx = inputData.move.x > 0 ? 1 : inputData.move.x < 0 ? -1 : 0;
                const my = inputData.move.y > 0 ? 1 : inputData.move.y < 0 ? -1 : 0;

                const scoreMultiplier = 1 + teamComp.score / 30000;
                let speed;
                if (teamComp.team === TEAM_HUMAN) {
                    speed = HUMAN_SPEED * scoreMultiplier;
                } else if (teamComp.team === TEAM_ZOMBIE) {
                    speed = ZOMBIE_SPEED * scoreMultiplier;
                } else {
                    speed = SICK_SPEED * scoreMultiplier;
                }

                let vx = mx * speed * 60;
                let vy = my * speed * 60;

                // Normalize diagonal movement using fixed-point math
                if (mx !== 0 && my !== 0) {
                    const INV_SQRT2 = 46341; // 0.7071 * 65536
                    vx = toFloat(fpMul(toFixed(vx), INV_SQRT2));
                    vy = toFloat(fpMul(toFixed(vy), INV_SQRT2));
                }

                player.setVelocity(vx, vy);
            } else {
                player.setVelocity(0, 0);
            }

            // Aiming with mouse (aim input is already in world coordinates)
            if (inputData.aim) {
                const dx = inputData.aim.x - transform.x;
                const dy = inputData.aim.y - transform.y;
                teamComp.aimAngle = Math.atan2(dy, dx) + Math.PI / 2;
            }
        }
    }, { phase: 'update' });

    // Game phase management system
    game.addSystem(() => {
        const state = getGameState();
        if (!state) return;

        state.gameTick++;

        const players = Array.from(game.query('player'));

        // Auto-start round when 2+ players join
        if (state.phase === PHASE_WAITING && players.length >= 2) {
            startRound();
        }

        // Phase transitions
        const ticksInPhase = state.gameTick - state.phaseStartTick;

        if (state.phase === PHASE_PREOUTBREAK) {
            // Make players sick 45 seconds in
            if (state.sickInfectionTick === 0 && ticksInPhase >= (TIME_PREOUTBREAK - TIME_SICK)) {
                makeSomePlayersSick();
            }

            // Start outbreak at 60 seconds
            if (ticksInPhase >= TIME_PREOUTBREAK) {
                startOutbreak();
            }
        }

        if (state.phase === PHASE_POSTOUTBREAK) {
            // Check win conditions
            const humans = players.filter(p => p.get(TeamComponent).team === TEAM_HUMAN).length;
            const zombies = players.filter(p => p.get(TeamComponent).team === TEAM_ZOMBIE).length;

            if (humans === 0 && zombies > 0) {
                endRound('zombies');
            } else if (zombies === 0 && humans > 0) {
                endRound('humans');
            }
        }

        updateUI();
    }, { phase: 'update' });

    // Furniture rotation system - apply angular velocity to Transform2D.angle
    game.addSystem(() => {
        for (const furniture of game.query('furniture')) {
            const body = furniture.get(Body2D);
            const transform = furniture.get(Transform2D);

            if (!body || !transform) continue;

            // Apply angular velocity to angle
            if (body.angularVelocity && Math.abs(body.angularVelocity) > 0.0001) {
                transform.angle += body.angularVelocity;

                // Apply angular damping (slow down rotation over time)
                body.angularVelocity *= 0.95;

                // Stop if very slow
                if (Math.abs(body.angularVelocity) < 0.001) {
                    body.angularVelocity = 0;
                }
            }
        }
    }, { phase: 'update' });

    // Infection via collision (player-player collision handler)
    game.onCollision('player', 'player', (player1, player2) => {
        const state = getGameState();
        if (!state || state.phase !== PHASE_POSTOUTBREAK) return;

        const team1 = player1.get(TeamComponent);
        const team2 = player2.get(TeamComponent);

        // Zombie infects human
        if (team1.team === TEAM_ZOMBIE && team2.team === TEAM_HUMAN) {
            team2.team = TEAM_ZOMBIE;
            team1.score++;
        } else if (team2.team === TEAM_ZOMBIE && team1.team === TEAM_HUMAN) {
            team1.team = TEAM_ZOMBIE;
            team2.score++;
        }
    });

    // ====================================================================
    // COLLISION HANDLERS
    // ====================================================================

    // Player-furniture collision: Apply extra push force for better responsiveness
    game.onCollision('player', 'furniture', (player, furniture) => {
        const playerTransform = player.get(Transform2D);
        const furnitureTransform = furniture.get(Transform2D);
        const furnitureBody = furniture.get(Body2D);
        const playerBody = player.get(Body2D);
        const furnitureData = furniture.get(FurnitureData);

        if (!playerTransform || !furnitureTransform || !furnitureBody || !playerBody) return;

        // Skip if player is not moving (use dSqrt for determinism)
        const playerSpeed = dSqrt(playerBody.vx * playerBody.vx + playerBody.vy * playerBody.vy);
        if (playerSpeed < 10) return; // Minimum speed threshold

        // Get furniture dimensions for better collision point calculation
        const furnitureWidth = furnitureData ? furnitureData.w : TILE;
        const furnitureHeight = furnitureData ? furnitureData.h : TILE;

        // Calculate the collision point on the furniture's edge
        // This is more accurate than using the player's center
        const relX = playerTransform.x - furnitureTransform.x;
        const relY = playerTransform.y - furnitureTransform.y;

        // Clamp the collision point to the furniture's boundaries
        const halfWidth = furnitureWidth / 2;
        const halfHeight = furnitureHeight / 2;
        const collisionX = Math.max(-halfWidth, Math.min(halfWidth, relX));
        const collisionY = Math.max(-halfHeight, Math.min(halfHeight, relY));

        // Calculate push direction (from player to furniture)
        const dx = furnitureTransform.x - playerTransform.x;
        const dy = furnitureTransform.y - playerTransform.y;
        const dist = dSqrt(dx * dx + dy * dy);

        if (dist > 0.01) { // Avoid division by zero
            // Push force based on player movement
            const pushStrength = Math.min(playerSpeed * 0.4, 120);
            const pushX = (dx / dist) * pushStrength;
            const pushY = (dy / dist) * pushStrength;

            // Apply linear impulse
            furnitureBody.impulseX += pushX;
            furnitureBody.impulseY += pushY;

            // Calculate torque using the actual push force and collision point
            // Torque = r Ã— F (cross product of position vector and force vector)
            // The sign determines rotation direction:
            // Positive = counterclockwise, Negative = clockwise
            const torque = (collisionX * pushY - collisionY * pushX) * 0.00001; // Reduced scale factor for reasonable values

            // Apply angular velocity with mass consideration
            // Heavier furniture should rotate less
            const massEffect = 3 / (furnitureBody.mass || 5);
            const adjustedTorque = torque * massEffect;

            // Use much smaller max angular velocity (0.5 radians/second = ~30 degrees/second)
            const maxAngularVelocity = 0.5;
            const currentAngVel = furnitureBody.angularVelocity || 0;
            const newAngularVelocity = currentAngVel + adjustedTorque;
            furnitureBody.angularVelocity = Math.max(-maxAngularVelocity,
                Math.min(maxAngularVelocity, newAngularVelocity));

            // Debug logging
            console.log(`Collision: point(${collisionX.toFixed(1)}, ${collisionY.toFixed(1)}), ` +
                       `force(${pushX.toFixed(1)}, ${pushY.toFixed(1)}), torque=${torque.toFixed(5)}, ` +
                       `adjustedTorque=${adjustedTorque.toFixed(5)}, ` +
                       `currentAngVel=${currentAngVel.toFixed(5)} -> newAngVel=${furnitureBody.angularVelocity.toFixed(5)}`);
        }
    });

    // ====================================================================
    // HELPER FUNCTIONS (Updated to use new ECS API)
    // ====================================================================
    function startRound() {
        const state = getGameState();
        if (!state) return;

        state.phase = PHASE_PREOUTBREAK;
        state.phaseStartTick = state.gameTick;
        state.sickInfectionTick = 0;
        state.outbreakTick = 0;

        // Reset ALL players to human and respawn in spawn region
        const spawn = cfg.regions.spawn;
        const spawnWidth = spawn.width * TILE;
        const spawnHeight = spawn.height * TILE;
        const spawnBaseX = spawn.x * TILE;
        const spawnBaseY = spawn.y * TILE;

        for (const player of game.query('player')) {
            const teamComp = player.get(TeamComponent);
            const playerComp = player.get(Player);
            const transform = player.get(Transform2D);
            const body = player.get(Body2D);

            // Reset team and score
            teamComp.team = TEAM_HUMAN;
            teamComp.score = 0;

            // Respawn in spawn region using deterministic hash
            const hash = hashString(playerComp.clientId);
            const x = spawnBaseX + ((hash >>> 0) % spawnWidth);
            const y = spawnBaseY + ((hash >>> 16 ^ hash) % spawnHeight);

            // Reset position
            transform.x = x;
            transform.y = y;

            // Stop any movement
            if (body) {
                body.vx = 0;
                body.vy = 0;
            }
        }

        // Reset all furniture to initial positions and rotations
        for (const furniture of game.query('furniture')) {
            const furnitureData = furniture.get(FurnitureData);
            const transform = furniture.get(Transform2D);
            const bodyComp = furniture.get(Body2D);

            if (furnitureData && transform) {
                console.log(`Resetting furniture: current(${transform.x.toFixed(1)}, ${transform.y.toFixed(1)}) -> initial(${furnitureData.initialX.toFixed(1)}, ${furnitureData.initialY.toFixed(1)})`);

                // For DYNAMIC bodies, we must set the physics body position directly
                // (Transform2D is overwritten by physics in postPhysics phase)
                const physicsBody = physics.getBody(furniture);
                if (physicsBody) {
                    // Set physics body position (uses fixed-point internally)
                    physicsBody.position.x = toFixed(furnitureData.initialX);
                    physicsBody.position.y = toFixed(furnitureData.initialY);
                    physicsBody.angle = toFixed(furnitureData.initialAngle);
                    // Stop movement
                    physicsBody.linearVelocity.x = 0;
                    physicsBody.linearVelocity.y = 0;
                    physicsBody.angularVelocity = 0;
                }

                // Also set transform for immediate visual update
                transform.x = furnitureData.initialX;
                transform.y = furnitureData.initialY;
                transform.angle = furnitureData.initialAngle;
            }

            // Reset Body2D component velocities too
            if (bodyComp) {
                bodyComp.vx = 0;
                bodyComp.vy = 0;
                bodyComp.angularVelocity = 0;
                bodyComp.impulseX = 0;
                bodyComp.impulseY = 0;
                bodyComp.angularImpulse = 0;
            }
        }
    }

    function makeSomePlayersSick() {
        const state = getGameState();
        if (!state) return;

        const players = Array.from(game.query('player'));

        // Sort for determinism (must be consistent order across all clients)
        const humans = players
            .filter(p => p.get(TeamComponent).team === TEAM_HUMAN)
            .sort((a, b) => (a.get(Player).clientId || 0) - (b.get(Player).clientId || 0));

        const numToInfect = Math.max(1, Math.floor(humans.length * OUTBREAK_RATIO));

        // Fisher-Yates shuffle using dRandom() for determinism across all clients
        const shuffled = [...humans];
        for (let i = shuffled.length - 1; i > 0; i--) {
            const j = Math.floor(dRandom() * (i + 1));
            [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
        }

        for (let i = 0; i < numToInfect && i < shuffled.length; i++) {
            shuffled[i].get(TeamComponent).team = TEAM_SICK;
        }

        state.sickInfectionTick = state.gameTick;
    }

    function startOutbreak() {
        const state = getGameState();
        if (!state) return;

        state.phase = PHASE_POSTOUTBREAK;
        state.outbreakTick = state.gameTick;

        // Convert all sick players to zombies
        for (const player of game.query('player')) {
            const teamComp = player.get(TeamComponent);
            if (teamComp.team === TEAM_SICK) {
                teamComp.team = TEAM_ZOMBIE;
            }
        }
    }

    function endRound(winner) {
        const state = getGameState();
        if (!state) return;

        state.phase = PHASE_ENDED;
        setTimeout(() => {
            const players = Array.from(game.query('player'));
            if (players.length >= 2) startRound();
            else {
                const s = getGameState();
                if (s) s.phase = PHASE_WAITING;
            }
        }, 5000);
    }

    function updateUI() {
        const state = getGameState();
        if (!state) return;

        const players = Array.from(game.query('player'));
        const humans = players.filter(p => p.get(TeamComponent).team === TEAM_HUMAN).length;
        const zombies = players.filter(p => p.get(TeamComponent).team === TEAM_ZOMBIE).length;
        const sick = players.filter(p => p.get(TeamComponent).team === TEAM_SICK).length;

        const phaseEl = document.getElementById('phase');
        const ticksInPhase = (state.gameTick || 0) - (state.phaseStartTick || 0);

        if (state.phase === PHASE_WAITING) {
            phaseEl.textContent = 'Waiting for players...';
        } else if (state.phase === PHASE_PREOUTBREAK) {
            const secondsLeft = Math.max(0, Math.ceil((TIME_PREOUTBREAK - ticksInPhase) / TICK_RATE));
            phaseEl.innerHTML = `Pre-outbreak: ${secondsLeft}s | <span class="team-humans">Humans: ${humans}</span> | Sick: ${sick}`;
        } else if (state.phase === PHASE_POSTOUTBREAK) {
            phaseEl.innerHTML = `<span class="team-humans">Humans: ${humans}</span> | <span class="team-zombies">Zombies: ${zombies}</span>`;
        } else {
            phaseEl.textContent = 'Round ended!';
        }
    }

    // ====================================================================
    // CONNECT TO SERVER
    // ====================================================================
    game.connect('brains', callbacks);
    Modu.enableDebugUI(game);
}
</script>
</body>
</html>